ID,Requirement,Usage Patterns,Categories,In/Out Scope,Implementation Notes,How new spec handles this
R-001,Deposit must support arbitrary file formats,"UP-001, UP-018",Protocol,In,"The protocol can continue to be file agnostic, though note that in the current version of the spec repositories may specify what formats or format ranges they support.  Should this indication be scaled back?  It's possible that for the most part application/zip is the most commonly delivered format, which hides whatever formats are actually inside the zip, making any other mime-type declarations at the repository level meaningless.","use of sword:accept allows the repository to define limits, and by default there are no limits on supported file formats.
"
R-002,Deposit must support arbitrarily large files,"UP-001, UP-027",Protocol,In,This is more a statement about having mechanisms in the protocol to work around limitations in implementations and intermediate specs (e.g. HTTP).,"Use of sword:maxUploadSize allows the repository to define limits, and by default there are no limits.  See also R-043, R-044, R-054"
R-003,Metadata/Content + Metadata deposits should support one or more metadata formats/profiles,UP-002,"Protocol, Content Aware",In/Out,"Right now, meatata deposits can take anything that can be embedded as XML in the atom entry, but there is no clean way of identifying the schema or profile of the content.  Content deposit allows a Packaging header which allows identification of the package format.  An equivalent mechanism for metadata is what's needed","Metadata deposit can now use the MetadataFormat header to indicate content format, combining it with Content-Type gives the server enough information to choose how to ingest.  Content + Metadata deposits at the same time can now only be done as a package, and the Packaging header serves the same purpose here."
R-004,Metadata/Content + Metadata deposits should enable unambiguous identification of metadata formats/profiles contained therein,UP-002,"Protocol, Content Aware",In/Out,See comment for R-003,See R-003
R-005,Identifiers should exist for common metadata formats/profiles as per R-004,UP-002,Content Aware,Out,"As an adjunct to SWORD, there should be an effort focussed around registering, describing and identifying formats/profiles.  This would have applicability outside just deposit processes.  Note that most formats or profiles probably do already have identifiers we could use.  Should there be a sword-maintained registry of them to help implementers?  Would we be able to generate a community of implementers allowing express support of such formats?",Not covered by the spec
R-006,Content/Content + Metadata deposits should enable unambigious identification of content format/profiles contained therein,UP-002,"Protocol, Content Aware",In/Out,See comment for R-003,See R-003
R-007,Identifiers should exist for common content formats/profiles as per R-006,UP-002,Content Aware,Out,See comment for R-003,Not covered by the spec
R-008,Authentication for any action must not require human intervention on any individual request,"UP-003, UP-010",Protocol,In,"This probably excludes anything like OAuth.  The current http basic works fine in this sense, but is not the most up-to-date or best practice security.  Other suggestions include some form of Public Key Infrastructure, but that might be an implementation detail.  We may need to just limit ourselves to saying that it must be possible to authenticate and identify a depositing user. Maybe the spec needs to give the repo a way to announce which auth schemes it supports","Authentication is now only lightly touched on by the protocol, encouraging users to choose their own approaches.  The spec has a sword:authentication field (which still needs work) to allow users to discover the authtentication schemes supported by the server"
R-009,Protocol operations must be possible over a secure connection,UP-003,Protocol,In,"Check that the spec does not preclude this, and indeed encourages it.  Nontheless, ultimately probably an implementation detail",Spec recommends TLS
R-010,"Authentication processes must be as strong as possible, in the context of other requirements",UP-003,Protocol,In,See comment for R-008,See R-008
R-011,Deposit of metadata records only must be possible (i.e. no file content associated),UP-004,Protocol,In,"Straightforward, currently supported",POST a metadata record to the Collection URI
R-012,Metadata and content must be depositable at the same time,UP-005,"Protocol, Content Aware",In/Out,"Right now we use Atom Multipart for this, which has failed in implementations, so it should be removed from the spec.  The only other way to support this is for us to define a package format which takes a metadata file, and for that metadata to be equivalent to what you could put in the atom entry document if you weren't sending the content.  Recommend something basic and well understood, like a BagIt profile.",This is now only possible if the metadata is in the package.  A standardised package format is provided using BagIt for lowest-common-denominator interchange.
R-013,"Content may be of a complex type, consisting of multiple files, file relationships and metadata",UP-005,"Protocol, Content Aware",In,Support for packaged content.  Support for individual file uploads.  File relationships and more complex structures may not be supportable outside of a package that the repository knows how to interpret.,Support for packaged content pushes this to a content-level issue.  Spec supports a Packaging header as before to allow client/server agreement on the format of such a message.
R-014,"It must be possible to add content to an already deposited item at a later date.  As per R-013, content may be complex",UP-006,Protocol,In,"SWORD has a mechanism for this using the Atom semantics.  It's difficult for the client to know if this operation will succeed, as the repository can change access to the item over time.  One complaint levelled at sword is the complexity of doing stuff like this, with all the various URLs for different purposes.  We should  consider departing from Atom and developing a more minimal spec, which is more fit for purpose.  We have not seen any particular benefit in the tool-chain from adopting Atom.","PUT a package to the Content URI (replaces all), POST a file to the Content URI (adds individual file), POST a package to the Object URI (adds multiple files + any metadata) "
R-015,"Servers should expose information about whether an item is editable (e.g. for R-014), or the conditions under which an item will cease to be editable",UP-006,Protocol,In,Related to R-014,"It's very difficult to describe in a machine-readable way the conditions under which an item would cease to be editable, and it's unlikely that clients will be complex enough to make use of such information.  

The spec now allows the status report for the object to identify which of the protocol operations are currently allowed against it."
R-016,"Deposit should be possible in a single operation, with no requirement by the client to receive the response or follow it up later",UP-007,Protocol,In,"What about error handling?  Client probably at least needs to get a response code.  I don't think that's contentions, SWORDv1 did that","Clients can deposit a package or metadata, receive their acknowledgement or error, and leave it at that"
R-017,Be able to specify item-level embargo on deposit,UP-008,"Protocol, Content Aware",Out,"Embargo would need to either be in package content metadata or headers.  If embargo can be in metadata layer only, this imples a multi-stage deposit, and maybe that's what you'd want.  Confirm with the repository that it will accept your embargo (and maybe other terms) before depositing","Not explicitly supported.

Implementation options for those using the metadata for this purpose would be:

1.  Extend the default sword metadata to include embargo/access restriction controls

2. Define and use a new metadata schema which includes embargo/access restriction roles

3. To use both the default sword metadata document AND a separate access control payload (e.g. in XML) which is deposited to the created item via a POST to the Object URL or Metadata URL (since it's not defined in the spec, implementations could choose their preferred way)"
R-018,Be able to update item-level embargo on subsequent update,UP-008,"Protocol, Content Aware",Out,See R-017,See R-017
R-019,Be able to specify access restrictions at an item-level (see also R-017),"UP-008, UP-037","Protocol, Content Aware",Out,"This has to be done at the package level, or in the same way as the embargo in R-017.  Treat embargo as a special case of an access restriction",See R-017
R-020,Be able to modify access restrictions at an item-level on a subsequent update (see also R-019),"UP-008, UP-037","Protocol, Content Aware",Out,See R-019,See R-019
R-021,Be able to retrieve information about an item's workflow state in the repository,"UP-009, UP-020","Protocol, Process Aware",In,"This is currently done through the Statement.  Workflow state is something the repository decides how to represent, so it is not universal.  Could we make a universal declaration, which repositories could also extend?","We have defined 6 key ingest progress states that repositories should use, and left it open for them to use their own states, and to allow an item to be in multiple states"
R-022,Be able to retrieve information about an item's current access restrictions in the repository,"UP-009, UP-037","Protocol, Content Aware",Out,"See also R-019 and R-017.  We'd need a common representation for access restrictions, for accepting and exposing them",See R-017 and R-019
R-023,"All information should be machine-readable: use of markup (e.g. XML), and URIs for status information",UP-010,Protocol,In,"First we should seriously consider moving on from Atom and creating a RESTful JSON specification.  This would, among other things, make implementations easier for developers.  Use of URIs is a given.  By separating ourselves from Atom, we could simplify the URL space, which may alleviate some of the concerns of developers.",Elements such as collectionPolicy and treatment now come with URIs.  All other fields which have a human-readable component already have URI counterparts.  All metadata is namespaced and use of JSON-LD makes it suitable for linked data representations.
R-024,Support metadata which pertains to grouping/set information around the item (e.g. ISSNs),UP-011,"Protocol, Content Aware",Out,"This is just metadata, and up to the repository what they do with it.  Even if we become content-aware, this won't matter to sword",No special treatment required
R-025,"There should be no restriction on the repository as to what kind of item it creates in response to a deposit, provided that item responds according to the protocol.  E.g. this could be a single item in the repository, or result in a ""collection"" being created.  It should be at the repository's discretion how to unpack an object to a suitable internal representation.","UP-011, UP-017, UP-024",Protocol,In,"I don't think there's any implications for the spec around this.  At the most it's to make sure that we don't presume the kind of object that's created, which we shouldn't do anyway",No special treatment required
R-026,Be able to determine when an item which was previously deposited is no longer available in the repository,UP-012,Protocol,In,"Right now this is just a 404, but a tombstone option could be relevant, possibly with the forwarding information (see R-028) if relevant","There is a sword:status which can be used to annotate a record which is a tombstone, if the repository would rather use that than a 404 (which it still can use)"
R-027,"Be able to determine if the item previously deposited has moved to a new location (there may be more than one new location for the item, e.g. if it has been deposited to multiple destinations)","UP-012, UP-026",Protocol,In,"See also R-026.  Add in the possibility of multiple forwarding addresses.  Those forwarding addresses may not give the clients authentication credentials any recognition, though.",Addition of sword:forwarding element allows the repository to respond with either/both of an onward object-url for sword operations or useful links to the item created in the forwarded location
R-028,Support proxying/forwarding of requests (i.e. 30x responses are legal within the spec),UP-012,Protocol,In,Explicitly support 30x in the spec,Appropriate 30x header codes are now explicit in the spec
R-029,"Be able to determine on deposit if the content will be moved to a new location later, or will disappear after some amount of time","UP-012, UP-026",Protocol,In,"The existing sword protocol could do this with the ""treatment"" element, but this is textual and in line with R-023 this should be machine readable instead.  Probably looking for something equivalent to a TTL, maybe with upper and lower bounds for how long","After consideration, it is concluded that this is  a very specific and difficult to represent set of information.  sword:treatment has been extended to allow a URI, which may go a small way towards making that field useful in a linked data context, but otherwise recommend that the text body of the sword:treatment element is where this information is recorded. It is anticipated that most integrations will know what the overall behaviour of the server is."
R-030,"Deposited files should be available for retrieval by the original depositor immediately (this may be limited to the actual deposited bitstreams, so the contents of a package may not be available individually, but the package itself should be)","UP-013, UP-014",Process Aware,In,Originally deposited files should be linked in initial deposit response (as sword already supports),"No impact on the spec itself, just inserted as a responsibility for the server"
R-031,File replacements should be available for retrieval by the original depositor as the lastest version of that file immediately (see R-030),"UP-013, UP-014",Protocol,In,"Have to be a bit careful about the meaning of this.  The newly deposited file should be available to the depositor (not necessarily anyone else) straight away.  This might cause some confusion, if the old version of the file is still available to other people until after some unspecified time/workflow.","No impact on the spec itself, just inserted as a responsibility for the server"
R-032,Be able to delete individual files from the deposited item,UP-015,Protocol,In,This is current functionality,DELETE on File URI
R-033,Be able to replace individual files in the deposited item in a later request,UP-016,Protocol,In,This is current functionality,PUT on File URI
R-034,Be able to retrieve the latest version of a file which has been replaced one or more times,"UP-014, UP-016",Protocol,In,"This is just retrieving a file that has overwritten a previous file, so should be covered by current functionality.  See also R031",GET on File URI
R-035,Be able to identify and retrieve older versions of a file which has been replaced one or more times (this would need to be optional),UP-016,Protocol,In,"This depends on the repository's capabilities, so at the best is just some semantics we offer to allow the repository to specify relationships between current files and previous files when it reports to the client.  Have to be careful that this isn't confusing for the client, too, and that reading the ""current"" version of the item is not complicated.",a sword:link with a dcterms:isReplacedBy and dcterms:replaces and a sword:versionReplaced for when the version was superseded.
R-036,"Re-use ResourceSync semantics where possible, relevant and appropriate",UP-017,Protocol,In,"ResourceSync is based on Google Sitemaps, is in XML, and is principally concerned with change lists.  Possible places where we may look for shared semantics: Resource Dump (for by-reference deposits) and Change Dump (for the same for updates).","After reviewing the ResourceSync semantics, it's not clear that there's anywhere that we can meaningfully use it in sword"
R-037,Should be possible to create content objects with minimal or no metadata attached,"UP-019, UP-028",Protocol,In,Current behaviour.  The result will be repository specific,No special treatment required
R-038,Be able to deposit content which is not yet ready to archive or put into an ingest workflow,"UP-021, UP-022, UP-041",Protocol,In,Use the In-Progress header (or equivalent in any new version of the spec).,Use In-Progress header as before
R-039,"Be able to deposit additional content to a previously ""incomplete"" deposit (see R-038)","UP-021, UP-022, UP-041",Protocol,In,"See R-038.  This is already supported, places some burden on the repo, so perhaps they need to be able to announce whether they support it or not","Use sword:actions to determine what updates are possible, and then the appropriate protocol operations.  Service Document allows the repository to declare whether it supports In-Progress deposits."
R-040,"Be able to identify when a previously ""incomplete"" deposit is now complete, and ready for archiving or ingest workflow","UP-021, UP-022",Protocol,In,"See R-038.  There needs to be an option for a special ""I'm finished"" message as there is at the moment","Send an empty In-Progress: false request, or add In-Progress:false to any operation on the object url"
R-041,Be able to determine when an item has completed the workflow and is in the repository/archive,UP-022,Protocol,In,"The current specification allows for status reporting, though the stutuses themselves are repository-specific.  Perhaps some of them need to be baked into the specification?","Use the sword-defined sword:state for ""archived"""
R-042,Support a common metadata + content packaging format which is supported throughout all sword implementations,UP-023,"Protocol, Content Aware",In/Out,"This already exists in parts: DC is mandated in the entry document, and a ""simple zip"" is supported in the package format.  Perhaps a combination of these, or some other bagit based package format that must be supported is what's required.  Any such package would have to have the absolute bare minimum information and still be valid, otherwise we would be getting too much into the formats of the content held by the repositories.","Continue to require SimpleZip support, and use the new JSON-based DC metadata format.  Also provides a new BagIt format which formally supports content and metadata in a standard way."
R-043,Support streamed content deposit,UP-025,Protocol,Out,"A small amount of research about streaming suggests that server-side support for streaming uploads might be fiddly or difficult.  I'd suggest that we steer clear of anything of that nature, so that implementers can create full working versions, and encourage depositers to use alternative chunked upload approaches (which we will need to explicitly support, e.g R-044).",No attempt to explicitly support
R-044,Allow files to be deposited in segments which are re-assembled on the server-side,"UP-027, UP-040",Protocol,In,"We can look at the DANS implementation for an example, though suggest formalising a little more.  We need to be able to: signify that a segmented upload has begun; upload the segments, specifying the order they come in, and indicate when the final segment has been sent.  This could be done in the headers, for example.","Use ContentDisposition to mark up a deposit into segments.  Start with a POST to Collection then continue to POST to Object, with suitable sequence id and number, and termination flag.  In these cases, In-Progress deposit should also be sent, and the repository should assume that it is true if it is not explicit.  The status document has semantics to indicate that a segmented file is being deposited."
R-045,Be able to authenticate a deposit by a user known to the repository,UP-029,Protocol,In,"This just means that it should be possible to authenticate using credentials of someone with a repository account.  This is currently the case, so can probably keep existing capabilities.  Ensure this fits with the other authNZ requirements.",This will be down to the repositories to implement over whatever authentication protocol they prefer
R-046,Be able to take a deposit on behalf of a user known to the repository,UP-030,Protocol,In,"We already support an on-behalf-of deposit.  There is no formal validation that the authenticated user is allowed to deposit on behalf of a user - that is left to the repository implementation.  How widely used is this feature, and what are the trust issues?  Does sword need to say any more about it?","There's nothing sword can do about the trust issues here.  It needs to be up to the repository to decide whether to support mediation, and how to authorise one user to deposit on behalf of another"
R-047,Be able to authorise a user to deposit content on behalf of a user known to the repository,UP-030,Protocol,In,See R-046,See R046
R-048,"Provide responses to client requets which contain URIs suitable for use in Linked Data, especially URIs which adequately identify the deposited item and its parts",UP-031,Protocol,In,"See also R-023.  SWORD is already good at this, just need to keep doing what we're doing.  There may be some benefit in simplifying the URLs, if we move away from Atom.",There are URIs for just about everything
R-049,"Be able to provide identifiers to the repository during deposit which reference related items at other URIs, and the types of those relationships (i.e. support a Linked Data approach)",UP-031,Content Aware,Out,"This is a metadata format issue, and not one that SWORD should address explicitly.",No special treatment required
R-050,Client should be able to identify and choose a deposit endpoint to submit content to (e.g. a logical collection in the repsitory),UP-032,Protocol,In,The service document currently provides this capability,"Use the service document.  The new version of the service document support hierarchical collections without having to carry out repeat HTTP requests.  Also, allowed the repository to set global deposit properties and override them on a per-collection basis"
R-051,Client should be able to navigate a collection hierarchy to find a suitable deposit endpoint,UP-032,Protocol,In,The service document currently provides this capability,Hierarchical service document allows this
R-052,Be able to deposit individual files (i.e. not in a package) to the repository,UP-033,Protocol,In,This is supported by the current spec both as an initial deposit containing only one file or as an individual file added to an existing item,"Post to Collection URI without package format, or with package format Binary"
R-053,Be able to add individual files (i.e. not in a package) to an existing item,UP-033,Protocol,In,See R-052,POST to Content URI
R-054,Be able to provide one or more files (individual files or packages) as URI references for the repository to download as part of the deposit process.,"UP-027, UP-034",Protocol,In,"The main questions around deposit by reference are:
1. What requirements are placed on the service providing the reference?  e.g. does it support resumable downloads?
2. How long will the reference persist?
3. Should the reference be downloaded, or should the repository just record the URL for use by end-users?
4. Are there file size limits on deposit by reference?
5. Should we harmonise the semantics with ResourceSync if appropriate?
6. Do we need to tell the reference server when we have finished with the file?","A number of by-reference features are now supported:
1. by-reference size limit can be declared separately to the upload size limit (sword:maxByReferenceSize)
2. Support for by-reference deposit is declared in the service document
3. The sword metadata deposit format allows for zero or more by-reference files to be deposited
4. The status document allows the status of by-reference deposits to be tracked until they are fully dereferenced"
R-055,Be able to provide one or more files (individual files or packages) as URI references for the repository to maintain a reference to (but not to copy) as part of the deposit process,UP-034,Protocol,In,"You could view this as just a metadata issue, but if we are supporting by-reference deposit where dereferencing is expected (R-054) then it would probably make sense to support this requirement in the same way, perhaps just with a ""don't download"" flag.",By reference deposit also supports a flag to indicate the repository should or should not download the reference.
R-056,The server should be able to know how long a by-reference deposit (see R-054) will be available for it to download,UP-034,Protocol,In,See R-054,By reference deposit provides a TTL field which contains a timestamp indicating how long the resource will be available for
R-057,"The server should have a process to handle the situation where the by-reference deposit (see R-054) is unavailable, or download fails part-way through",UP-034,Protocol,In,"Probably the server will need to be able to provide an error log to the client when an update on the item is requested.  We're therefore suggesting that by-reference deposits should come with a certain amount of follow-up by the client to make sure everything is fine.  Does this mean that the repository needs to provide some status information about how it's doing with downloading the reference file?  Like ""queued"", ""downloading"", ""done"" etc.  Also does it need to give the client an idea how long until it gets around to it?","The Status document can indicate if a download has failed, and describe the reasons"
R-058,"The server should be able to announce and enforce file-size limits for deposited content, by value or by reference",UP-034,Protocol,In,"This is already the case by value, so just need to be clear that the limit applies by reference.  This also may place a requirement on the provider of the reference to give a content-length header when the resource is requested.  Not essential, but could save the server having to download the resource until it reaches the size limit.","sword:maxUploadSize and sword:maxByReferenceSize; do we need to consider the difference between a max segment size, and a maximum resulting file size?"
R-059,The server should be able to hit callbacks provided by the client at key points in the deposit workflow,UP-035,Protocol,Out,"This places too much burden on the server, with the additional complexities which involve calling a remote link.  It also implies that the sword interface would pervade the entire repository workflow, which it may not be able to.",No action
R-060,The server should be allowed to accept a deposit without processing it synchronously to the client's request,UP-036,Protocol,In,Just respond with a 202 in these cases,Server may now respond with a 202.
R-061,"Clients must be able to monitor ""accepted"" but not yet processed deposits, to determine when they have been completed",UP-036,Protocol,In,See R-041 - this is likely just an additional status.,sword:state with a set of standard statuses allows this
R-062,Be able to specify detailed file-level access restrictions during deposit,UP-037,Content Aware,Out,"See R-017 - any solution for embargo could be extendable to a more thorough access restrictions set.  Places burdens on the repository to support access restrictions, so may need to be able to announce levels of support.",See R-017
R-063,Be able to update file-level access restrictions at some time after deposit,UP-037,Content Aware,Out,See R-062,See R-062
R-064,Be able to expose validation and minimum requirements for metadata and/or content being deposited/updated,UP-038,"Protocol, Content Aware",In/Out,"Propose that the spec contains the capability to pass validation messages, but does not say anything about validation itself.  Validation and minimum requirements should come from the definition of the package or metadata format, which will need to be handled outslde the spec.","Server should use an error document and the sword:log field for this information.  If the server accepts a record but does not process it straight away, the originalDeposit record could be annotated with a sword:log record in the event that validation has failed.

This is a minimal approach to validation, as it should not be a significant part of the spec."
R-065,"Format identification URIs (e.g. for packages) should be able to handle a hierarchy of increasing specificity.  e.g. a URI may identify a DSpace METS SIP, which is in turn a refinement on a METS package, which is in turn a refinement of a plain unstructured package",UP-038,Content Aware,In/Out,This is a question for a package registry,No action
R-066,"Repositories should be able to expose their level of protocol support (particularly any optional components), protocol version, and supported content types",UP-039,Protocol,In,"Review the requirements above, and identify which elements are optional or variable.  Then we just need an extensible portion of the spec which allows the repo to announce its support levels",Every aspect of the protocol can now be determined through the service document through feature flags.  Actions then available on individual deposited items are also available as flags in the status document