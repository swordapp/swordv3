<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SWORD 3.0 Specification</title>

    <link rel="stylesheet" href="assets/css/swordv3.css">
</head>
<body>



    <h1 class="main_title">SWORD 3.0 Specification</h1>

    <div class="nav">
        <div class="toc">
            <ul>
<li><a href="#1">1. Credits</a></li>
<li><a href="#2">2. Introduction</a></li>
<li><a href="#3">3. Notational Conventions</a></li>
<li><a href="#4">4. Protocol Operations</a><ul>
<li><a href="#4.1">4.1. Error Responses</a></li>
<li><a href="#4.2">4.2. Redirects</a></li>
<li><a href="#4.3">4.3. HTTP Requests</a><ul>
<li><a href="#4.3.1">4.3.1. GET Service-URL</a></li>
<li><a href="#4.3.2">4.3.2. POST Service-URL</a></li>
<li><a href="#4.3.3">4.3.3. GET Object-URL</a></li>
<li><a href="#4.3.4">4.3.4. POST Object-URL</a></li>
<li><a href="#4.3.5">4.3.5. PUT Object-URL</a></li>
<li><a href="#4.3.6">4.3.6. DELETE Object-URL</a></li>
<li><a href="#4.3.7">4.3.7. GET Metadata-URL</a></li>
<li><a href="#4.3.8">4.3.8. PUT Metadata-URL</a></li>
<li><a href="#4.3.9">4.3.9. DELETE Metadata-URL</a></li>
<li><a href="#4.3.10">4.3.10. PUT FileSet-URL</a></li>
<li><a href="#4.3.11">4.3.11. DELETE FileSet-URL</a></li>
<li><a href="#4.3.12">4.3.12. GET File-URL</a></li>
<li><a href="#4.3.13">4.3.13. PUT File-URL</a></li>
<li><a href="#4.3.14">4.3.14. DELETE File-URL</a></li>
<li><a href="#4.3.15">4.3.15. POST Staging-URL</a></li>
<li><a href="#4.3.16">4.3.16. GET Temporary-URL</a></li>
<li><a href="#4.3.17">4.3.17. POST Temporary-URL</a></li>
<li><a href="#4.3.18">4.3.18. DELETE Temporary-URL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5">5. Protocol Requirements</a><ul>
<li><a href="#5.1">5.1. Requirement Hierarchies</a></li>
<li><a href="#5.2">5.2. Requirement Groups</a></li>
</ul>
</li>
<li><a href="#6">6. Documents</a><ul>
<li><a href="#6.1">6.1. JSON-LD Context</a></li>
<li><a href="#6.2">6.2. Service Document</a></li>
<li><a href="#6.3">6.3. Metadata Document</a></li>
<li><a href="#6.4">6.4. By-Reference Document</a></li>
<li><a href="#6.5">6.5. Metadata + By-Reference Document</a></li>
<li><a href="#6.6">6.6. Status Document</a><ul>
<li><a href="#6.6.1">6.6.1. Available <code>rel</code> types and their meanings</a></li>
<li><a href="#6.6.2">6.6.2. Required SWORD State Information</a></li>
<li><a href="#6.6.3">6.6.3. Ingest Statuses for Individual Files</a></li>
</ul>
</li>
<li><a href="#6.7">6.7. Segmented File Upload Document</a></li>
<li><a href="#6.8">6.8. Error Document</a><ul>
<li><a href="#6.8.1">6.8.1. Error Types</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7">7. Authentication and Authorisation</a><ul>
<li><a href="#7.1">7.1. Announcing Support for Authentication Schemes</a></li>
<li><a href="#7.2">7.2. Authentication and Authorisation in requests</a></li>
<li><a href="#7.3">7.3. Authentication and Authorisation responses</a></li>
<li><a href="#7.4">7.4. Recording Depositing Users</a></li>
</ul>
</li>
<li><a href="#8">8. Content Disposition</a></li>
<li><a href="#9">9. Segmented File Upload</a><ul>
<li><a href="#9.1">9.1. Announcing Support for Segmented File Upload</a></li>
<li><a href="#9.2">9.2. Outline of Process for Segmented File Upload</a></li>
<li><a href="#9.3">9.3. Segmented Upload Initialisation</a></li>
<li><a href="#9.4">9.4. Uploading File Segments</a></li>
<li><a href="#9.5">9.5. Retrieving Information about a Segmented File Upload</a></li>
<li><a href="#9.6">9.6. Aborting an Upload</a></li>
<li><a href="#9.7">9.7. Incomplete Upload Retention</a></li>
<li><a href="#9.8">9.8. Completed Upload Retention</a></li>
<li><a href="#9.9">9.9. Errors</a></li>
</ul>
</li>
<li><a href="#10">10. Metadata Deposit</a><ul>
<li><a href="#10.1">10.1. Announcing Support for Metadata Formats</a></li>
<li><a href="#10.2">10.2. Indicating Metadata Format to the Server</a></li>
</ul>
</li>
<li><a href="#11">11. Metadata Formats</a><ul>
<li><a href="#11.1">11.1. Default Format</a></li>
<li><a href="#11.2">11.2. Depositing Other Formats</a></li>
<li><a href="#11.3">11.3. Representing Other Formats in the Service Document</a></li>
</ul>
</li>
<li><a href="#12">12. Packaging Formats</a><ul>
<li><a href="#12.1">12.1. Binary</a></li>
<li><a href="#12.2">12.2. SimpleZip</a></li>
<li><a href="#12.3">12.3. SWORDBagIt</a></li>
</ul>
</li>
<li><a href="#13">13. Auto-Discovery</a><ul>
<li><a href="#13.1">13.1. For Services</a></li>
<li><a href="#13.2">13.2. For Objects</a></li>
<li><a href="#13.3">13.3. Well-Known URI</a></li>
</ul>
</li>
<li><a href="#14">14. References</a></li>
</ul>
        </div>
    </div>

    <div class="spec">

        <p><strong>Version</strong>: SWORD 3.0 Release Candidate 1</p>
<p><strong>Last modified</strong>: 2020-07-22 09:01</p>
        <p>See also: <a href="/swordv3-behaviours.html">SWORD 3.0 Behaviours</a> which provides a denormalised view of the specification's
protocol operations.</p>
<h1><a name="1"></a>1. Credits</h1>
<p><strong>Technical Lead</strong>: Richard Jones, Cottage Labs</p>
<p><strong>Community Lead</strong>: Neil Jefferies, University of Oxford</p>
<p><strong>Funded By</strong>: NII, Jisc, EBSCO</p>
<p><strong>Funder Liaisons</strong>: Masaharu Hayashi, NII; Dom Fripp, Jisc; Christopher Spalding, EBSCO</p>
<p><strong>Technical Advisory Group</strong>:
Adam Rehin, Adrian Stevenson, Alan Stiles, Catherine Jones, Claire Knowles, David Moles, David Wilcox, Eoghan &Oacute; Carrag&aacute;in, Erick Peirson, 
Gertjan Filarski, Goosyara Kovbasniy, Graham Triggs, Hideaki Takeda, Jan van Mansum, Jauco Noordzij, Jochen Schirrwagen, John Chodacki,
Justin Simpson, Lars Holm Nielsen, Marisa Strong, Martin Wrigley, Masaharu Hayashi, Masud Khokhar, Mike Jackson,
Morane Gruenpeter, Neil Chue Hong, Paul Walk, Peter Sefton, Ralf Claussnitzer, Ricardo Otelo Santos Saraiva Cruz, Richard Rodgers, 
Scott Wilson, Shannon Searle, Stephanie Taylor, Stuart Lewis, Tomasz Parkola, Vitali Peil</p>
<h1><a name="2"></a>2. Introduction</h1>
<p>SWORD 3.0 is a protocol enabling clients and servers to communicate around complex digital objects, especially with regard to supporting the
deposit of these objects into a service like a digital repository.  Complex digital objects consist of both Metadata and File content, 
where the Files may be in a variety of formats, there may be many files, and some may be very large.  The protocol defines semantics for
creating, appending, replacing, deleting, and retrieving information about these complex resources.  It also enables servers to communicate
regarding the status of treatment of deposited content, such as exposing ingest workflow information.</p>
<p>The first major version of SWORD [<a href="#sword_1.3">SWORD 1.3</a>] built upon the Resouce creation aspects of AtomPub [<a href="#atompub">AtomPub</a>] to enable 
fire-and-forget package deposit onto a server.</p>
<p>This approach, where the depositor has no further interaction with the server is of significant value in certain use cases, but there are 
others where this is insufficient. Consider, for example, that the depositor wishes to construct a digital artifact file by file over a 
period of time before deciding that it is time to archive it. In these cases, a higher level of interactivity between the participating 
systems is required, and this is the role that SWORD 2.0 [<a href="#sword_2.0">SWORD 2.0</a>] was subsequently developed to fulfil.</p>
<p>As the use cases for SWORD have developed further, it became clear that the increasing size of files repositories were being asked to deal
with was an issue.  As a result of this, and the fact that the technological approach for SWORD 2.0 was starting to show its age, a new
version, SWORD 3.0, has been developed.  This is a radical departure from SWORD 2.0, eliminating ties with AtomPub, and moving to a much
stricter REST+JSON approach, utilising JSON-LD for alignment with Linked Data.  Its key differences to SWORD 2.0 from a functional
perspective are:</p>
<ul>
<li>Support for By-Reference file deposit</li>
<li>Support for Segmented file deposit</li>
<li>More advanced native packaging and metadata formats</li>
</ul>
<h1><a name="3"></a>3. Notational Conventions</h1>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
document are to be interpreted as described in [<a href="#rfc2119">RFC2119</a>].</p>
        <h1><a name="4"></a>4. Protocol Operations</h1>
<p>This section lists the actual on-the-wire protocol operations that are part of SWORDv3.  Actual usage of each of these operations is 
dependent on the action that you wish to take.  See <a href="#5">Protocol Requirements</a> for the rules which govern how to use these Protocol 
Operations.</p>
<p>The full set of protocol operations is available as an OpenAPI definition [<a href="#openapi">OpenAPI</a>], available as <a href="/openapi.json">JSON</a>
and <a href="/openapi.yaml">YAML</a>.</p>
<h2><a name="4.1"></a>4.1. Error Responses</h2>
<p>The following error responses are possible against some or all of the HTTP Requests.  In each case an Error Document MUST be returned by the 
server with details as to the root cause of the error.</p>
<ul>
<li><strong>400 (BadRequest)</strong> - The server could not understand your request.  Either your headers or content body are wrong or malformed.</li>
<li><strong>401 (Unauthorized)</strong> - You have not provided authentication information, please do so</li>
<li><strong>403 (Forbidden)</strong> - You are not authorised to access this resource, or the operation you requested is not possible in this context</li>
<li><strong>404 (Not Found)</strong> - There is no resource available at the URL you requested</li>
<li><strong>405 (Method Not Allowed)</strong> - The HTTP method you requested on the resource is not permitted/available in this context</li>
<li><strong>410 (Gone)</strong> - The resource existed in the past but is no longer present at the URL you requested</li>
<li><strong>412 (Precondition Failed)</strong> - There is a problem implementing the request as-is.  This can happen for the following reasons: your checksums may not match, you may have requested mediated deposit when the server does not support that, your headers may not be consistent with each other, your If-Match headers may not mat the current ETag, or your Segmented Upload Initialisation request may not be within parameters acceptable to the server.</li>
<li><strong>413 (Payload Too Large)</strong> - Your request body exceeds the size allowed by the server</li>
<li><strong>415 (Unsupported Media Type)</strong> - The metadata format is not the same as that identified in Metadata-Format and/or it is not supported by the server, or the packaging format is not the same as that identified in Packaging and/or it is not supported by the server</li>
</ul>
<h2><a name="4.2"></a>4.2. Redirects</h2>
<p>Some requests may result in redirect codes being sent to the client; the server MAY respond to any request with a suitable redirect.  These 
are the redirect codes that are used, and what they mean:</p>
<ul>
<li><strong>301 (Moved Permanently)</strong> - The URL you requested has changed, re-send this request and all future requests to the new URL</li>
<li><strong>307 (Temporary Redirect)</strong> - The URL you requested has temporarily changed, re-send this request to the new URL</li>
<li><strong>308 (Permanent Redirect)</strong> - The URL you requested has changed, re-send this request and all future requests to the new URL</li>
</ul>
<h2><a name="4.3"></a>4.3. HTTP Requests</h2>
<p>These are the HTTP requests that are covered by the SWORD protocol.</p>
<p>Each request MAY be responded to by the server with a redirect code (see above).  Each request MAY also generate an error; possible errors 
are listed for each section, please refer to the section above for details on the meanings of errors.</p>
<h3><a name="4.3.1"></a>4.3.1. GET Service-URL</h3>
<div class="openapi"><p>Retrieve the Service Document</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>Service Document<br><br><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.2"></a>4.3.2. POST Service-URL</h3>
<div class="openapi"><p>Make a new Object</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>Content-Disposition</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Digest</li>
<li>In-Progress</li>
<li>Metadata-Format</li>
<li>On-Behalf-Of</li>
<li>Packaging</li>
<li>Slug</li>
</ul>
<p><strong>Body</strong></p>
<p>Content used to create new Object.  This can be one of: Metadata, By-Reference, Metadata+By-Reference, Binary File, Packaged Content, Empty Body</p>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>201</td>
<td>Resource created, responds with Status Document<br><br><strong>Headers</strong><ul><li>Location - Object-URL</li><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>202</td>
<td>Resource accepted for processing, responds with Status Document<br><br><strong>Headers</strong><ul><li>Location - Object-URL</li><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td></td>
</tr>
<tr>
<td>415</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.3"></a>4.3.3. GET Object-URL</h3>
<div class="openapi"><p>Retrieve the Status information for the Object</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>Status Document<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.4"></a>4.3.4. POST Object-URL</h3>
<div class="openapi"><p>Append data to an Object</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>Content-Disposition</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Digest</li>
<li>If-Match</li>
<li>In-Progress</li>
<li>On-Behalf-Of</li>
<li>Packaging</li>
<li>Metadata-Format</li>
</ul>
<p><strong>Body</strong></p>
<p>Content to be appended to the Object.  This can be one of: Metadata, By-Reference, Metadata+By-Reference, Binary File, Packaged Content, Empty Body</p>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>Content appended, responds with Status Document<br><br><strong>Headers</strong><ul><li>Location - The File-URL of the Original Deposit File if present</li><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>202</td>
<td>Content accepted for append, responds with Status Document<br><br><strong>Headers</strong><ul><li>Location - The File-URL of the Original Deposit File if present</li><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td></td>
</tr>
<tr>
<td>415</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.5"></a>4.3.5. PUT Object-URL</h3>
<div class="openapi"><p>Replace the Object</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>Content-Disposition</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Digest</li>
<li>If-Match</li>
<li>In-Progress</li>
<li>On-Behalf-Of</li>
<li>Packaging</li>
<li>Metadata-Format</li>
</ul>
<p><strong>Body</strong></p>
<p>Content to replace the Object.  This can be one of: Metadata, By-Reference, Metadata+By-Reference, Binary File, Packaged Content, Empty Body</p>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>Replace carried out, responds with Status Document<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>202</td>
<td>Replace accepted for action, responds with Status Document<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td></td>
</tr>
<tr>
<td>415</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.6"></a>4.3.6. DELETE Object-URL</h3>
<div class="openapi"><p>Delete the Object</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>If-Match</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>202</td>
<td>Delete request accepted for processing<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>204</td>
<td>Object Deleted<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.7"></a>4.3.7. GET Metadata-URL</h3>
<div class="openapi"><p>Retrieve the Metadata</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>Metadata Document<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.8"></a>4.3.8. PUT Metadata-URL</h3>
<div class="openapi"><p>Replace the Metadata</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>Content-Disposition</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Digest</li>
<li>If-Match</li>
<li>On-Behalf-Of</li>
<li>Metadata-Format</li>
</ul>
<p><strong>Body</strong></p>
<p>Content to replace the Metadata.  This must be a Metadata Document.</p>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>204</td>
<td>Metadata Replaced, no response body<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td></td>
</tr>
<tr>
<td>415</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.9"></a>4.3.9. DELETE Metadata-URL</h3>
<div class="openapi"><p>Delete the metadata of an Object</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>If-Match</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>202</td>
<td>Delete request accepted for processing<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>204</td>
<td>Metadata Deleted<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.10"></a>4.3.10. PUT FileSet-URL</h3>
<div class="openapi"><p>Replace the FileSet</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>Content-Disposition</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Digest</li>
<li>If-Match</li>
<li>On-Behalf-Of</li>
<li>Packaging</li>
</ul>
<p><strong>Body</strong></p>
<p>Content to replace the FileSet.  This can be one of: By-Reference, Binary File, Empty Body</p>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>202</td>
<td>FileSet replacement accepted for processing, no response body<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>204</td>
<td>FileSet Replaced, no response body<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td></td>
</tr>
<tr>
<td>415</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.11"></a>4.3.11. DELETE FileSet-URL</h3>
<div class="openapi"><p>Delete the FileSet</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>If-Match</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>202</td>
<td>Delete request accepted for processing<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>204</td>
<td>FileSet Deleted<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.12"></a>4.3.12. GET File-URL</h3>
<div class="openapi"><p>Retrieve an individual File</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>Binary File<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>*/*</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.13"></a>4.3.13. PUT File-URL</h3>
<div class="openapi"><p>Replace an individual File</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>Content-Disposition</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Digest</li>
<li>If-Match</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Body</strong></p>
<p>Content to replace the File.  This can be one of: By-Reference, Binary File, Empty Body</p>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>204</td>
<td>Binary File replaced, no response body<br><br><strong>Headers</strong><ul><li>ETag - version identifier</li></ul><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td></td>
</tr>
<tr>
<td>415</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.14"></a>4.3.14. DELETE File-URL</h3>
<div class="openapi"><p>Delete an individual File</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>If-Match</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>202</td>
<td>Delete request accepted for processing<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>204</td>
<td>Binary File Deleted<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.15"></a>4.3.15. POST Staging-URL</h3>
<div class="openapi"><p>Create a Temporary-URL for Segmented File Upload</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>Content-Disposition</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>201</td>
<td>Temporary-URL created<br><br><strong>Headers</strong><ul><li>Location - The Temporary-URL to which Segmented File Upload requests can be sent</li></ul><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.16"></a>4.3.16. GET Temporary-URL</h3>
<div class="openapi"><p>Retrieve Information on a Segmented File Upload</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>Segmented File Upload Document<br><br><strong>Body</strong><ul><li>application/json</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.17"></a>4.3.17. POST Temporary-URL</h3>
<div class="openapi"><p>Upload a File Segment</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>Content-Disposition</li>
<li>Content-Length</li>
<li>Digest</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Body</strong></p>
<p>Segment to be added to the Resource.</p>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>204</td>
<td>Segment Received<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td></td>
</tr>
</tbody>
</table></div>

<h3><a name="4.3.18"></a>4.3.18. DELETE Temporary-URL</h3>
<div class="openapi"><p>Abort a Segmented File Upload</p>
<p><strong>Headers</strong></p>
<ul>
<li>Authorization</li>
<li>On-Behalf-Of</li>
</ul>
<p><strong>Responses</strong></p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>202</td>
<td>Delete request accepted for processing<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>204</td>
<td>Temporary File Deleted<br><br><strong>Body</strong><ul><li>None</li></ul></td>
</tr>
<tr>
<td>400</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td></td>
</tr>
</tbody>
</table></div>
        <h1><a name="5"></a>5. Protocol Requirements</h1>
<p>This section describes the requirements of every kind of operation that you can do with SWORDv3.  Each section in 
<a href="#5.2">Requirement Groups</a> identifies which Request Conditions have what requirements.  To determine
the requirements for a specific request, identify each block below which is relevant to your request, and this will
provide the overall protocol requirements for that operation.</p>
<p>Converting the below into a set of requirements for a specific request is time consuming, so this has been done for
you in the <strong><a href="/swordv3-behaviours.html">SWORDv3 Behaviours Document</a></strong>. If you are implementing a SWORD client
or server it is <strong>STRONGLY RECOMMENDED</strong> that you work from that document rather than the normalised requirements below.</p>
<p>There are 3 key aspects of the Request Conditions where requirements can be applied, and these are:</p>
<ol>
<li><strong>Request</strong>: The operation that you are performing on the resources</li>
<li><strong>Content</strong>: The body content of the request, such as Metadata, By-Reference, Metadata+ByReference, Binary File, Packaged Content, Empty Body</li>
<li><strong>Resource</strong>: Service-URL<sup>[<a href="#service-url">def</a>]</sup>, Object-URL<sup>[<a href="#object-url">def</a>]</sup>, Metadata-URL<sup>[<a href="#metadata-url">def</a>]</sup>, FileSet-URL<sup>[<a href="#fileset-url">def</a>]</sup>, File-URL<sup>[<a href="#file-url">def</a>]</sup>, Staging-URL<sup>[<a href="#staging-url">def</a>]</sup>, Temporary-URL<sup>[<a href="#temporary-url">def</a>]</sup></li>
</ol>
<p>When combined for a specific request, these aspects tell you the exact requirements.  For example: Creating (<strong>Request</strong>) a new Object by request to the Service-URL (<strong>Resource</strong>) 
with Packaged Content (<strong>Content</strong>)</p>
<p>Each of these aspects of the Request Conditions are presented below according to a hierarchy. For a specific aspect,
you must import the requirements for it and all its parents in the hierarchy, to obtain all the requierements for the
request.</p>
<p>For each Request Condition, up to 4 kinds of requirement are present:</p>
<ol>
<li><strong>Protocol Operation</strong>: which of the protocol operations MUST be used for this request</li>
<li><strong>Request Requirements</strong>: constraints applied to the client request</li>
<li><strong>Server Requirements</strong>: constraints applied to how the server handles the request</li>
<li><strong>Response Requirements</strong>: constraints applied to how the server responds to the request</li>
</ol>
<p>See the document <a href="/swordv3-behaviours.html">SWORDv3 Behaviours</a> to see each of the behaviours SWORDv3 is 
capable of with its requirements fully expanded.</p>
<h2><a name="5.1"></a>5.1. Requirement Hierarchies</h2>
<p>The hierarchy for the Request is:</p>
<ul>
<li>All<ul>
<li>Complete</li>
<li>Retrieve</li>
<li>Modify<ul>
<li>Create</li>
<li>Update<ul>
<li>Replace</li>
<li>Append</li>
</ul>
</li>
</ul>
</li>
<li>Delete</li>
</ul>
</li>
</ul>
<p>The hierarchy for the Content is:</p>
<ul>
<li>All<ul>
<li>Empty Body</li>
<li>Body<ul>
<li>JSON<ul>
<li>Metadata</li>
<li>By-Reference</li>
<li>MD+BR</li>
</ul>
</li>
<li>Binary<ul>
<li>Binary File</li>
<li>Packaged Content</li>
<li>File Segment</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The hierarchy for the Resource is:</p>
<ul>
<li>All<ul>
<li>Deposit<ul>
<li>Components<ul>
<li>FileSet-URL</li>
<li>File-URL</li>
<li>Metadata-URL</li>
</ul>
</li>
<li>Service-URL</li>
<li>Object-URL</li>
</ul>
</li>
<li>Staging<ul>
<li>Staging-URL</li>
<li>Temporary-URL</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>So, for example, when considering an Request Condition such as "Creating Objects with Packaged Content", this would be take requirements as follows:</p>
<ul>
<li>For the Request, as a Create, it takes requirements from <strong>Create</strong>, <strong>Modify</strong> and <strong>All</strong></li>
<li>For the Content, as Packaged Content, it takes requirements from <strong>Packaged Content</strong>, <strong>Binary</strong>, <strong>Body</strong> and <strong>All</strong></li>
<li>For the Resource, as an operation on the Service-URL, it takes requirements from <strong>Service-URL</strong>, <strong>Deposit</strong> and <strong>All</strong></li>
</ul>
<h2><a name="5.2"></a>5.2. Requirement Groups</h2>
<div class="requirement-groups">

<p><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: All</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY specify <code>Authorization</code> and <code>On-Behalf-Of</code> headers (i.e. if authenticating this request)</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If <code>Authorization</code> (and optionally <code>On-Behalf-Of</code>) headers are provided, MUST authenticate the request</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>If no authentication credentials were supplied, but were expected, MUST respond with a <code>401</code> (AuthenticationRequired)</li>
<li>If authentication fails with supplied credentials, MUST respond with a <code>403</code> (AuthenticationFailed)</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Retrieve</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Service-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>GET Service-URL</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>If <code>Authorization</code> (and optionally <code>On-Behalf-Of</code>) headers are provided, MUST only list Service-URLs in the Service Document for which a deposit request would be permitted</li>
<li>MUST respond with a valid Service Document or a suitable error response</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Retrieve</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>GET Object-URL</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a valid Status document or a suitable error response</li>
<li>MUST include <code>ETag</code> header if implementing concurrency control</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Retrieve</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Components</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST include <code>ETag</code> header if implementing concurrency control</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Retrieve</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Metadata-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>GET Metadata-URL</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a valid Metadata document (see definition below) or a suitable error response</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Retrieve</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: File-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>GET File-URL</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a File (which may be Packaged Content, a Binary File, a Metadata document, or any other file that the server exposes) or a suitable error response</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MUST provide the <code>Content-Disposition</code> header, with the appropriate value for the request</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Deposit</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST include <code>ETag</code> header if implementing concurrency control</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: Body</li>
<li><strong>Resource</strong>: Deposit</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MUST provide the <code>Content-Type</code> header</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If all preconditions are met, MUST either accept the deposit request immediately, queue the request for processing, or respond with an error</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST include one or more File-URLs for the deposited content in the Status document.  The behaviour of these File-URLs may vary depending on the type of content deposited (e.g. ByReference and Segmented Uploads do not need to be immediately retrievable)</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: Body</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MUST provide the <code>Digest</code> header</li>
<li>SHOULD provide the <code>Content-Length</code></li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>MUST verify that the content matches the <code>Digest</code> header</li>
<li>MUST verify that the supplied content matches the <code>Content-Length</code> if this is provided</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: Metadata</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>SHOULD provide the <code>Metadata-Format</code> header</li>
<li>MUST provide only the Metadata document</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If no <code>Metadata-Format</code> header is provided, MUST assume this is the standard SWORD format: http://purl.org/net/sword/3.0/types/Metadata</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: By-Reference</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MUST provide the By-Reference document</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If downloading copies of the files in the By-Reference document, MUST do this asynchronously to the deposit request</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: By-Reference</li>
<li><strong>Resource</strong>: File-URL</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MUST only include a single By-Reference File in the By-Reference document</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If more than one By-Reference File is present, MUST reject the request.</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>If rejecting the request due to the presence of more than one By-Reference File in the By-Reference Document, MUST respond with a <code>400</code></li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: MD+BR</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>SHOULD provide the <code>Metadata-Format</code> header</li>
<li>MUST provide the Metadata+By Reference document</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If no <code>Metadata-Format</code> header is provided, MUST assume this is the standard SWORD format: http://purl.org/net/sword/3.0/types/Metadata</li>
<li>If downloading copies of the files in the By-Reference document, MUST do this asynchronously to the deposit request</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: Binary</li>
<li><strong>Resource</strong>: Deposit</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the request MUST attach the supplied file to the Object as an <code>originalDeposit</code></li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: Binary File</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY provide the <code>Packaging</code> header, and if so MUST be the Binary format identifier</li>
<li>MUST provide Binary File body content</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>The server SHOULD NOT attempt to unpack the file</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: Packaged Content</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MUST provide the <code>Packaging</code> header</li>
<li>MUST provide Packaged Content in the request body</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>The server MAY attempt to unpack the file, and create <code>derivedResource</code>s from it.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Modify</li>
<li><strong>Content</strong>: Empty Body</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY provide the <code>Content-Length</code> header with value <code>0</code></li>
<li>MUST NOT include any body content</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Create</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Service-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>POST Service-URL</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY provide the <code>Slug</code> header</li>
<li>MAY provide the <code>In-Progress</code> header</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If a <code>Slug</code> header is provided, MAY use this as the identifier for the newly created Object.</li>
<li>If accepting the request MUST create a new Object</li>
<li>If no <code>In-Progress</code> header is provided, MUST assume that it is <code>false</code></li>
<li>If <code>In-Progress</code> is <code>false</code>, SHOULD expect further updates to the item, and not progress it through any ingest workflows yet.</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>Location</code> header, containing the Object-URL</li>
<li>MUST respond with a valid Status document or a suitable error response</li>
<li>Status document MUST be available on GET to the Object-URL in the <code>Location</code> header immediately (irrespective of whether this is a <code>201</code> or <code>202</code> response)</li>
<li>MUST respond with a <code>201</code> if the item was created immediately, a <code>202</code> if the item was queued for import, or raise an error.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Create</li>
<li><strong>Content</strong>: Metadata</li>
<li><strong>Resource</strong>: Service-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the request MUST populate the Object with the supplied Metadata</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Create</li>
<li><strong>Content</strong>: By-Reference</li>
<li><strong>Resource</strong>: Service-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the request MUST attach the By-Reference files to the Object.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Create</li>
<li><strong>Content</strong>: MD+BR</li>
<li><strong>Resource</strong>: Service-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the request MUST populate the Object with the supplied Metadata, and attach the By-Reference files to it.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Create</li>
<li><strong>Content</strong>: Empty Body</li>
<li><strong>Resource</strong>: Staging-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>POST Staging-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If all preconditions are met, MUST create a resource to which the client can upload file segments</li>
<li>MUST reject the request if the conditions of the upload are not acceptable</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>201</code> to indicate that the Segmented Upload has been initialised, or raise an error.</li>
<li>MUST respond with a <code>Location</code> header containing the Temporary-URL where the client can upload file segments</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Update</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Deposit</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MUST include the <code>If-Match</code> header, if the server implements concurrency control</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>MUST reject the request if the <code>If-Match</code> header does not match the current <code>ETag</code> of the resource</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Update</li>
<li><strong>Content</strong>: Body</li>
<li><strong>Resource</strong>: Deposit</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>200</code> if the request was accepted immediately, a <code>202</code> if the request was queued for processing, or raise an error.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Update</li>
<li><strong>Content</strong>: Body</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY provide the <code>In-Progress</code> header</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If no <code>In-Progress</code> header is provided, MUST assume that it is <code>false</code></li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a valid Status document or a suitable error response</li>
<li>MUST include <code>ETag</code> header if implementing concurrency control</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Append</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>POST Object-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Append</li>
<li><strong>Content</strong>: Binary</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>Location</code> header, containing the File-URL of the Original Deposit File</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Append</li>
<li><strong>Content</strong>: Metadata</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new Metadata MUST add the Metadata to the item, and only treat this as an extension to existing Metadata.  The server MUST NOT overwrite or otherwise remove existing Metadata.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>PUT Object-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: Binary</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new File, MUST remove all existing Files from the Object and replace with the new File.  The new File should be marked as an <code>originalDeposit</code>.  The server MUST also remove all Metadata, so the Metadata Resource contains no fields.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: Metadata</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new Metadata, MUST remove all existing Files from the Object, and MUST replace the existing Metadata with the new.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: By-Reference</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new By-Reference files, MUST remove all existing Files from the Object and replace with the By-Reference files.  The server MUST remove the existing Files immediately, even before the By-Reference files have dereferenced.  The new files MUST be marked as <code>originalDeposit</code>s.  The server MUST also remove all Metadata, so the Metadata Resource contains no fields.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: MD+BR</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new Metadata and By-Reference files, MUST remove all existing Files from the Object and replace with the By-Reference files.  The server MUST remove the existing Files immediately, even before the By-Reference files have dereferenced.  The server MUST also replace all existing Metadata with the new Metadata.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: Metadata</li>
<li><strong>Resource</strong>: Metadata-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new Metadata MUST entirely replace the existing Metadata with the new.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: By-Reference</li>
<li><strong>Resource</strong>: FileSet-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new By-Reference Files, MUST replace the existing FileSet with the new files.  The server MUST remove all the old files immediately, even before the new By-Reference files have been dereferenced.  The new Files MUST be marked as <code>originalDeposit</code>s</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: Binary File</li>
<li><strong>Resource</strong>: FileSet-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new File, MUST replace the existing FileSet with a single new File.  The File MUST be marked as an <code>originalDeposit</code></li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: By-Reference</li>
<li><strong>Resource</strong>: File-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new By-Reference File, MUST replace the existing File.  The server MAY keep the previous file as an older version.  The new file MUST be marked as an <code>originalDeposit</code></li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: Binary File</li>
<li><strong>Resource</strong>: File-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the new File, MUST replace the existing File.  The server MAY keep the previous file as an older version.  The new File MUST be marked as an <code>originalDeposit</code></li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Update</li>
<li><strong>Content</strong>: Body</li>
<li><strong>Resource</strong>: Components</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>204</code> if the replacement was deposited immediately, a <code>202</code> if the replacement was queued for import, or raise an error.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Append</li>
<li><strong>Content</strong>: By-Reference</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the request, MUST attach all the By-Reference files to the Object as <code>originalDeposit</code>s</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Append</li>
<li><strong>Content</strong>: MD+BR</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If accepting the request, MUST attach all the By-Reference files to the Object as <code>originalDeposit</code>s, and MUST add the Metadata to the item, and only treat this as an extension to existing Metadata.  The server MUST NOT overwrite or otherwise remove existing Metadata.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Metadata-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>PUT Metadata-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: FileSet-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>PUT FileSet-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Replace</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: File-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>PUT File-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Delete</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: All</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>204</code> if the delete is successful, <code>202</code> if the delete is queued for processing, or raise an error</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Delete</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>DELETE Object-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Delete</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: FileSet-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>DELETE FileSet-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Delete</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: File-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>DELETE File-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Delete</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Metadata-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>DELETE Metadata-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Delete</li>
<li><strong>Content</strong>: All</li>
<li><strong>Resource</strong>: Temporary-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>DELETE Temporary-URL</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Complete</li>
<li><strong>Content</strong>: Empty Body</li>
<li><strong>Resource</strong>: Object-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>POST Object-URL</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MUST provide the header <code>In-Progress: false</code></li>
<li>MAY provide the <code>Content-Length</code> header with value <code>0</code></li>
<li>MUST NOT include any body content</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>MAY inject the content into any ingest workflows</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>204</code> or a suitable error</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Append</li>
<li><strong>Content</strong>: Body</li>
<li><strong>Resource</strong>: Temporary-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>POST Temporary-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>MUST reject the request if the segment is incorrect or unexpected: for example, all segments were already received, or the segment is a different size than expected.</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>204</code> or a suitable error</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Append</li>
<li><strong>Content</strong>: File Segment</li>
<li><strong>Resource</strong>: Temporary-URL</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If all preconditions are met, MUST accept the file segment, and record the receipt of it</li>
<li>MUST be prepared to accept file segments in any order, and in parallel</li>
<li>MUST be able to store the incoming file segments as they arrive, and then reconstitute them into a single file when all segments have been received.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Request</strong>: Retrieve</li>
<li><strong>Content</strong>: Empty Body</li>
<li><strong>Resource</strong>: Temporary-URL</li>
</ul>
<p><strong>Protocol Operation</strong></p>
<ul>
<li>GET Temporary-URL</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>MUST respond with a <code>200</code> or a suitable error</li>
<li>If successful, MUST respond with a Segmented File Upload Document describing the current state of the upload.</li>
</ul>
<hr>

</div>
        <h1><a name="6"></a>6. Documents</h1>
<h2><a name="6.1"></a>6.1. JSON-LD Context</h2>
<p>SWORD defines the semantics of its documents using JSON-LD [<a href="#json-ld">JSON-LD</a>].  You can see the full JSON-LD Context 
<a href="/swordv3.jsonld">here</a></p>
<h2><a name="6.2"></a>6.2. Service Document</h2>
<p>The Service Document defines the capabilities and operational parameters of the server as a whole, or of a particular Service-URL.</p>
<p>The Service Document consists of a set of properties at the root, and a list of "services".  Each service may define a Service-URL 
and/or additional properties and further nested "services".  For the purposes of normalising the data held in the Service Document (for 
brevity of the serialised document), the Service Document MAY specify at the root properties which MUST be taken to hold true for all 
nested "services" (at any level below) unless that lower service definition overrides the properties.  A service which sits beneath the root of 
the Service Document and above another Service, MAY also redefine properties, and those overrides MUST be considered to cascade down to 
Services beneath that one.</p>
<p>A Service Document can be retrieved either for the root of the service, or from any Service within the hierarchy of Services available. 
If the root Service Document is requested, the full list of Services, including all their children, MUST be provided.  If the URL of a 
Service is requested, it MUST only provide information about itself and its children.</p>
<p>The full JSON Schema [<a href="#json-schema">JSON-SCHEMA</a>] can be downloaded <a href="/service-document.schema.json">here</a>.</p>
<p>An example of the Service Document:</p>
<pre><code class="json">{
  &quot;@context&quot; : &quot;https://swordapp.github.io/swordv3/swordv3.jsonld&quot;,

  &quot;@id&quot; : &quot;http://example.com/service-document&quot;,
  &quot;@type&quot; : &quot;ServiceDocument&quot;,

  &quot;dc:title&quot; : &quot;Site Name&quot;,
  &quot;dcterms:abstract&quot; : &quot;Site Description&quot;,

  &quot;root&quot; : &quot;http://example.com/service-document&quot;,
  &quot;acceptDeposits&quot;: true,

  &quot;version&quot;: &quot;http://purl.org/net/sword/3.0&quot;,
  &quot;maxUploadSize&quot; : 16777216000,
  &quot;maxByReferenceSize&quot; : 30000000000000000,
  &quot;maxSegmentSize&quot; : 16777216000,
  &quot;minSegmentSize&quot; : 1,
  &quot;maxAssembledSize&quot; : 30000000000000,
  &quot;maxSegments&quot; : 1000,

  &quot;accept&quot; : [&quot;*/*&quot;],
  &quot;acceptArchiveFormat&quot; : [&quot;application/zip&quot;],
  &quot;acceptPackaging&quot; : [&quot;*&quot;],
  &quot;acceptMetadata&quot; : [&quot;http://purl.org/net/sword/3.0/types/Metadata&quot;],

  &quot;collectionPolicy&quot; : {
    &quot;@id&quot; : &quot;http://www.myorg.ac.uk/collectionpolicy&quot;,
    &quot;description&quot; : &quot;....&quot;
  },
  &quot;treatment&quot; : {
    &quot;@id&quot; : &quot;http://www.myorg.ac.uk/treatment&quot;,
    &quot;description&quot; : &quot;...&quot;
  },

  &quot;staging&quot; : &quot;http://example.com/staging&quot;,
  &quot;stagingMaxIdle&quot; : 3600,

  &quot;byReferenceDeposit&quot; : true,
  &quot;onBehalfOf&quot; : true,

  &quot;digest&quot; : [&quot;SHA-256&quot;, &quot;SHA&quot;, &quot;MD5&quot;],
  &quot;authentication&quot;: [&quot;Basic&quot;, &quot;OAuth&quot;, &quot;Digest&quot;, &quot;APIKey&quot;],

  &quot;services&quot; : [
    {
      &quot;@id&quot;: &quot;http://swordapp.org/deposit/43&quot;,

      &quot;dc:title&quot; : &quot;Deposit Service Name&quot;,
      &quot;dcterms:abstract&quot; : &quot;Deposit Service Description&quot;,

      &quot;root&quot; : &quot;http://example.com/service-document&quot;,
      &quot;parent&quot; : &quot;http://example.com/service-document&quot;,
      &quot;acceptDeposits&quot;: true,

      &quot;services&quot; : []
    }
  ]
}
</code></pre>

<p>The fields available are defined as follows:</p>
<p><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>@context</td>
<td>string</td>
<td>The JSON-LD Context for this document<br><br>MUST be present.</td>
</tr>
<tr>
<td>@id</td>
<td>string</td>
<td>The URL of the service document you are looking at<br><br>MUST be present.</td>
</tr>
<tr>
<td>@type</td>
<td>string</td>
<td>JSON-LD identifier for the document type<br><br>This field is used to define the type of the document, and in this case should always be 'ServiceDocument'.  MUST be present.</td>
</tr>
<tr>
<td>accept</td>
<td>array</td>
<td>List of Content Types which are acceptable to the server.<br><br>MUST be present.  '<em>/</em>' for any content type, or a list of acceptable content types</td>
</tr>
<tr>
<td>acceptArchiveFormat</td>
<td>array</td>
<td>List of Archive Formats that the server can unpack.  If the server sends a package using a different format, the server MAY treat it as a Binary File<br><br>SHOULD be present.  '<em>' for any archive format (not recommended), or a list of acceptable formats.  If this is omitted, the client MUST assume the server only supports application/zip</td>
</tr>
<tr>
<td>acceptDeposits</td>
<td>boolean</td>
<td>Does the Service accept deposits?<br><br>SHOULD be present.  If omitted, the client MUST assume that the service does not accept deposits.</td>
</tr>
<tr>
<td>acceptMetadata</td>
<td>array</td>
<td>List of Metadata Formats which are acceptable to the server.<br><br>SHOULD be present.  '</em>' for any metadata format, or a list of acceptable metadata formats.  Acceptable metadata formats SHOULD be an IRI for a known format, or any other identifying string if no IRI exists.  If this is omitted, the client MUST assume the server only supports the standard SWORD metadata format: http://purl.org/net/sword/3.0/types/Metadata</td>
</tr>
<tr>
<td>acceptPackaging</td>
<td>array</td>
<td>List of Packaging Formats which are acceptable to the server.<br><br>SHOULD be present.  '*' for any packaging format, or a list of acceptable packaging formats.  Acceptable packaging formats SHOULD be an IRI for a known format, or any other identifying string if no IRI exists.  If this is omitted, the client MUST assume the server only supports the 3 required SWORD packaging formats (see the section Packaging Formats)</td>
</tr>
<tr>
<td>authentication</td>
<td>array</td>
<td>List of authentication schemes supported by the server.<br><br>SHOULD be present.  If not provided the client MUST assume the server does not support authentication.</td>
</tr>
<tr>
<td>byReferenceDeposit</td>
<td>boolean</td>
<td>Does the server support By-Reference deposit?<br><br>SHOULD be present.   If omitted, the client MUST assume the server does not support By-Reference deposit.</td>
</tr>
<tr>
<td>collectionPolicy</td>
<td>object</td>
<td>URL and description of the servers collection policy.<br><br>MAY be present.</td>
</tr>
<tr>
<td>collectionPolicy.@id</td>
<td>string</td>
<td>Collection Policy URL</td>
</tr>
<tr>
<td>collectionPolicy.description</td>
<td>string</td>
<td>Collection Policy Description</td>
</tr>
<tr>
<td>dc:title</td>
<td>string</td>
<td>The title or name of the Service<br><br>MUST be present.</td>
</tr>
<tr>
<td>dcterms:abstract</td>
<td>string</td>
<td>A description of the service<br><br>MAY be present.</td>
</tr>
<tr>
<td>digest</td>
<td>array</td>
<td>The list of digest formats that the server will accept.<br><br>MUST be present, and MUST include SHA-256, MAY include any others.</td>
</tr>
<tr>
<td>maxAssembledSize</td>
<td>integer</td>
<td>Maximum size in bytes as an integer for the total size of an assembled segmented upload<br><br>SHOULD be present.  If omitted and segmented upload is supported, the client MUST assume the server will accept a file of any size.</td>
</tr>
<tr>
<td>maxByReferenceSize</td>
<td>integer</td>
<td>Maximum size in bytes as an integer for files uploaded by reference.<br><br>SHOULD be present.  If omitted, the client MUST assume the server will accept a file of any size.</td>
</tr>
<tr>
<td>maxSegmentSize</td>
<td>integer</td>
<td>Maximum size in bytes as an integer for an individual segment in a segmented upload<br><br>MAY be present.  If omitted and segmented upload is supported, the client MUST assume the maximum segment size is the same as maxUploadSize.</td>
</tr>
<tr>
<td>maxSegments</td>
<td>integer</td>
<td>Maximum number of segments that the server will accept for a single segmented upload, if segmented upload is supported.<br><br>SHOULD be present.  If omitted, the client MUST assume the server will accept any number of segments.</td>
</tr>
<tr>
<td>maxUploadSize</td>
<td>integer</td>
<td>Maximum size in bytes as an integer for files being uploaded.<br><br>SHOULD be present.  If omitted, the client MUST assume the server will accept an upload of any size.</td>
</tr>
<tr>
<td>minSegmentSize</td>
<td>integer</td>
<td>Minimum size in bytes as an integer for an individual segment in a segmented upload<br><br>MAY be present.  If omitted and segmented upload is supported, the client MUST assume the manimum segment size 1 byte.</td>
</tr>
<tr>
<td>onBehalfOf</td>
<td>boolean</td>
<td>Does the server support deposit on behalf of other users (mediation)<br><br>SHOULD be present.  If omitted, the client MUST assume the server does not support On-Behalf-Of deposit.</td>
</tr>
<tr>
<td>root</td>
<td>string</td>
<td>The URL for the root Service Document.<br><br>MUST be present.</td>
</tr>
<tr>
<td>services</td>
<td>array</td>
<td>List of Services contained within the parent service<br><br>MAY be present.</td>
</tr>
<tr>
<td>staging</td>
<td>string</td>
<td>The URL where clients may stage content prior to deposit, in particular for segmented upload<br><br>MAY be present.  If omitted, the client MUST assume the server does not support Segmented Upload.</td>
</tr>
<tr>
<td>stagingMaxIdle</td>
<td>integer</td>
<td>What is the minimum time a server will hold on to an incomplete Segmented File Upload since it last received any content before deleting it.<br><br>SHOULD be present.  If omitted, the client MUST assume that the server will hold on to the incomplete file indefinitely.  Servers MAY delete the unfinished upload at any time after the minimum time stated here has elapsed.</td>
</tr>
<tr>
<td>treatment</td>
<td>object</td>
<td>URL and description of the treatment content can expect during deposit.<br><br>MAY be present.</td>
</tr>
<tr>
<td>treatment.@id</td>
<td>string</td>
<td>Treatment URL</td>
</tr>
<tr>
<td>treatment.description</td>
<td>string</td>
<td>Treatment Description</td>
</tr>
<tr>
<td>version</td>
<td>string</td>
<td>The version of the SWORD protocol this server supports<br><br>MUST be present.</td>
</tr>
</tbody>
</table></p>
<h2><a name="6.3"></a>6.3. Metadata Document</h2>
<p>The default SWORD Metadata document allows the deposit of a standard, basic metadata document constructed using the DCMI terms [<a href="#dcmi">DCMI</a>].  This 
Metadata document can be sent when creating an Object initially, when appending to the metadata, or in replacing the metadata or indeed the 
Object as a whole.</p>
<p>The format of the document is simple and extensible (see the <a href="#11">Metadata Formats</a> section).  The <code>dc</code> and <code>dcterms</code> vocabularies are supported, 
and servers MUST support this metadata format.</p>
<p>The full JSON Schema [<a href="#json-schema">JSON-SCHEMA</a>] can be downloaded <a href="/metadata.schema.json">here</a>.</p>
<p>An example of the Metadata Document:</p>
<pre><code class="json">{
  &quot;@context&quot; : &quot;https://swordapp.github.io/swordv3/swordv3.jsonld&quot;,

  &quot;@id&quot; : &quot;http://example.com/object/1/metadata&quot;,
  &quot;@type&quot; : &quot;Metadata&quot;,

  &quot;dc:title&quot; : &quot;The title&quot;,
  &quot;dcterms:abstract&quot; : &quot;This is my abstract&quot;,
  &quot;dc:contributor&quot; : &quot;A.N. Other&quot;
}
</code></pre>

<p>The fields available are defined as follows:</p>
<p><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>@context</td>
<td>string</td>
<td>The JSON-LD Context for this document<br><br>MUST be present.</td>
</tr>
<tr>
<td>@id</td>
<td>string</td>
<td>The URL of the Metadata Document you are looking at<br><br>MUST be present.</td>
</tr>
<tr>
<td>@type</td>
<td>string</td>
<td>JSON-LD identifier for the document type<br><br>This field is used to define the type of the document, and in this case should always be 'Metadata'.  MUST be present.</td>
</tr>
<tr>
<td>^dc:.+$</td>
<td>string</td>
<td>Properties from the DC namespace<br><br>MAY be present.</td>
</tr>
<tr>
<td>^dcterms:.+$</td>
<td>string</td>
<td>Properties from the DCTERMS namespace<br><br>MAY be present.</td>
</tr>
</tbody>
</table></p>
<p>When sending this document, the client MUST provide a <code>Content-Disposition</code> header of the form:</p>
<pre><code>Content-Disposition: attachment; metadata=true
</code></pre>

<p>Additionally, when sending this document the client SHOULD provide the <code>Metadata-Format</code> header with the identifier 
for the format: http://purl.org/net/sword/3.0/types/Metadata</p>
<pre><code>Metadata-Format: http://purl.org/net/sword/3.0/types/Metadata
</code></pre>

<p>If the client omits the <code>Metadata-Format</code> header, the server MUST assume that it is the above format.</p>
<h2><a name="6.4"></a>6.4. By-Reference Document</h2>
<p>The By-Reference document allows the client to send a list of one or more files that the server will fetch asynchronously.  The 
By-Reference document can be sent when creating an Object initially, or when appending to or replacing the FileSet in the Object, or 
replacing the Object as a whole.</p>
<p>The full JSON Schema [<a href="#json-schema">JSON-SCHEMA</a>] can be downloaded <a href="/by-reference.schema.json">here</a>.</p>
<p>An example of the By-Reference Document:</p>
<pre><code class="json">{
  &quot;@context&quot; : &quot;https://swordapp.github.io/swordv3/swordv3.jsonld&quot;,

  &quot;@type&quot; : &quot;ByReference&quot;,

  &quot;byReferenceFiles&quot; : [
    {
      &quot;@id&quot; : &quot;http://www.otherorg.ac.uk/by-reference/file.zip&quot;,
      &quot;contentType&quot; : &quot;application/zip&quot;,
      &quot;contentLength&quot; : 123456,
      &quot;contentDisposition&quot; : &quot;attachment; filename=file.zip&quot;,
      &quot;packaging&quot; : &quot;http://purl.org/net/sword/packaging/SimpleZip&quot;,
      &quot;digest&quot; : &quot;SHA256=....&quot;,
      &quot;ttl&quot; : &quot;2018-04-16T00:00:00Z&quot;,
      &quot;dereference&quot; : true
    }
  ]
}
</code></pre>

<p>The fields available are defined as follows:</p>
<p><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>@context</td>
<td>string</td>
<td>The JSON-LD Context for this document<br><br>MUST be present.</td>
</tr>
<tr>
<td>@type</td>
<td>string</td>
<td>JSON-LD identifier for the document type<br><br>This field is used to define the type of the document, and in this case should always be 'ByReference'.  MUST be present.</td>
</tr>
<tr>
<td>byReferenceFiles</td>
<td>array</td>
<td>List of files to deposit By-Reference<br><br>MUST be present and contain one or more entries</td>
</tr>
<tr>
<td>byReferenceFiles[].@id</td>
<td>string</td>
<td>The URL of the file to be retrieved and deposited<br><br>MUST be present</td>
</tr>
<tr>
<td>byReferenceFiles[].contentDisposition</td>
<td>string</td>
<td>Content-Disposition as it would have been supplied if this were a regular file deposit.<br><br>MUST be present</td>
</tr>
<tr>
<td>byReferenceFiles[].contentLength</td>
<td>integer</td>
<td>Content-Length as it would have been supplied if this were a regular file deposit.<br><br>SHOULD be present</td>
</tr>
<tr>
<td>byReferenceFiles[].contentType</td>
<td>string</td>
<td>The Content-Type of the file to be retrieved and deposited<br><br>MUST be present</td>
</tr>
<tr>
<td>byReferenceFiles[].dereference</td>
<td>boolean</td>
<td>Should the server dereference the file (i.e. download it and store it locally) or should it simply maintain a link to the external resource.<br><br>MUST be present.  Note that servers MAY choose to do both, irrespective of the value here, though if <code>false</code>, the server should make the external link available to users accessing the resource.</td>
</tr>
<tr>
<td>byReferenceFiles[].digest</td>
<td>string</td>
<td>Digest as it would have been supplied if this were a regular file deposit.<br><br>MUST be present</td>
</tr>
<tr>
<td>byReferenceFiles[].packaging</td>
<td>string</td>
<td>The packaging format of the file, or the Binary file identifier<br><br>SHOULD be present.  If this is not provided, the server MUST assume this is the Binary format: http://purl.org/net/sword/3.0/package/Binary</td>
</tr>
<tr>
<td>byReferenceFiles[].ttl</td>
<td>string</td>
<td>A timestamp which indicates when the file will no longer be available (Time To Live).<br><br>MUST be formatted as UTC big-endian date as per [<a href="#note-datetime">NOTE-datetime</a>]. If no date is provided, the server MAY assume the file will be available indefinitely.</td>
</tr>
</tbody>
</table></p>
<p>When sending this document, the client MUST provide a <code>Content-Disposition</code> header of the form:</p>
<pre><code>Content-Disposition: attachment; by-reference=true
</code></pre>

<h2><a name="6.5"></a>6.5. Metadata + By-Reference Document</h2>
<p>In the event that the client wishes to send both Metadata and By-Reference content to the server, this is possible in
the event that the Metadata format is expressed as JSON, such as the default SWORD metadata format.</p>
<p>If the client wishes to send a metadata format that is not or cannot be expressed as JSON, this operation is not available,
it is provided only as a convenience.  In that case, a separate <a href="#10">Metadata Deposit</a> and {% mdinline %}{% autoescape off %}{{ section_link("By-Reference Deposit", "main") }}{% endautoescape %}{% endmdinline %}
should be carried out.</p>
<p>To do this, the client may include the Metadata and By-Reference documents embedded in a single JSON document, structured as shown below. 
The entire Metadata document (including its JSON-LD <code>@context</code> when using the default format) is embedded in a field 
entitled <code>metadata</code>, and the entire By-Reference document (again, with its JSON-LD <code>@context</code>) is embedded in a field entitled <code>by-reference</code>.</p>
<p>When a document of this form is sent, the client MUST set the <code>Content-Disposition</code> header appropriately, to alert the server of its 
required behaviour.</p>
<p>An example of the Metadata + By-Reference Document:</p>
<pre><code class="json">{
  &quot;metadata&quot; : {
    &quot;@context&quot; : &quot;https://swordapp.github.io/swordv3/swordv3.jsonld&quot;,
    &quot;@type&quot; : &quot;Metadata&quot;,

    &quot;dcterms:abstract&quot; : &quot;....&quot;,
    &quot;dc:contributor&quot; : &quot;...&quot;,
    &quot;etc...&quot; : &quot;....&quot;
  },

  &quot;by-reference&quot; : {
    &quot;@context&quot; : &quot;https://swordapp.github.io/swordv3/swordv3.jsonld&quot;,
    &quot;@type&quot; : &quot;ByReference&quot;,

    &quot;byReferenceFiles&quot; : []
  }
}
</code></pre>

<p>When sending this document, the client MUST provide a <code>Content-Disposition</code> header of the form:</p>
<pre><code>Content-Disposition: attachment; metadata=true; by-reference=true
</code></pre>

<p>Additionally, when sending this document the client SHOULD provide the <code>Metadata-Format</code> header with the identifier for the format: </p>
<pre><code>Metadata-Format: http://purl.org/net/sword/3.0/types/Metadata
</code></pre>

<p>If the client omits the <code>Metadata-Format</code> header, the server MUST assume that it is the default format: http://purl.org/net/sword/3.0/types/Metadata</p>
<h2><a name="6.6"></a>6.6. Status Document</h2>
<p>The status document is provided in response to a deposit operation on a Service-URL, and can be retrieved at any subsequent point by a
GET on the Object-URL, and is returned each time the client takes action on the Object-URL.  It tells the client detailed information about 
the content and current state of the item.</p>
<p>The full JSON Schema [<a href="#json-schema">JSON-SCHEMA</a>] can be downloaded <a href="/status.schema.json">here</a>.</p>
<p>An example of the Status Document:</p>
<pre><code class="json">{
  &quot;@context&quot; : &quot;https://swordapp.github.io/swordv3/swordv3.jsonld&quot;,

  &quot;@id&quot; : &quot;http://example.com/object/1&quot;,
  &quot;@type&quot; : &quot;Status&quot;,
  &quot;eTag&quot; : &quot;...&quot;,

  &quot;metadata&quot; : {
    &quot;@id&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/metadata&quot;,
    &quot;eTag&quot; : &quot;...&quot;
  },
  &quot;fileSet&quot; : {
    &quot;@id&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/fileset&quot;,
    &quot;eTag&quot; : &quot;...&quot;
  },

  &quot;service&quot; : &quot;http://swordapp.org/deposit/43&quot;,

  &quot;state&quot; : [
    {
      &quot;@id&quot; : &quot;http://purl.org/net/sword/3.0/state/inProgress&quot;,
      &quot;description&quot; : &quot;the item is currently inProgress&quot;
    }
  ],

  &quot;actions&quot; : {
    &quot;getMetadata&quot; : true,
    &quot;getFiles&quot; : true,
    &quot;appendMetadata&quot; : true,
    &quot;appendFiles&quot; : true,
    &quot;replaceMetadata&quot; : true,
    &quot;replaceFiles&quot; : true,
    &quot;deleteMetadata&quot; : true,
    &quot;deleteFiles&quot; : true,
    &quot;deleteObject&quot; : true
  },

  &quot;links&quot; : [
    {
      &quot;@id&quot; : &quot;http://www.myorg.ac.uk/col1/mydeposit.html&quot;,
      &quot;rel&quot; : [&quot;alternate&quot;],
      &quot;contentType&quot; : &quot;text/html&quot;
    },
    {
      &quot;@id&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/package.zip&quot;,
      &quot;rel&quot; : [&quot;http://purl.org/net/sword/3.0/terms/originalDeposit&quot;],
      &quot;contentType&quot; : &quot;application/zip&quot;,
      &quot;packaging&quot; : &quot;http://purl.org/net/sword/3.0/package/SimpleZip&quot;,
      &quot;depositedOn&quot; : &quot;[timestamp]&quot;,
      &quot;depositedBy&quot; : &quot;[user identifier]&quot;,
      &quot;depositedOnBehalfOf&quot; : &quot;[user identifier]&quot;,
      &quot;byReference&quot; : &quot;http://www.otherorg.ac.uk/by-reference/file.zip&quot;,
      &quot;status&quot; : &quot;http://purl.org/net/sword/3.0/filestate/ingested&quot;,
      &quot;log&quot; : &quot;[any information associated with the deposit that the client should know]&quot;
    },
    {
      &quot;@id&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/file1.pdf&quot;,
      &quot;rel&quot; : [
        &quot;http://purl.org/net/sword/3.0/terms/fileSetFile&quot;,
        &quot;http://purl.org/net/sword/3.0/terms/derivedResource&quot;
      ],
      &quot;contentType&quot; : &quot;application/pdf&quot;,
      &quot;derivedFrom&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/package.zip&quot;,
      &quot;dcterms:relation&quot; : &quot;http://www.myorg.ac.uk/repo/123456789/file1.pdf&quot;,
      &quot;dcterms:replaces&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/versions/file1.1.pdf&quot;,
      &quot;eTag&quot; : &quot;...&quot;
    },
    {
      &quot;@id&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/package.1.zip&quot;,
      &quot;rel&quot; : [&quot;http://purl.org/net/sword/terms/packagedContent&quot;],
      &quot;contentType&quot; : &quot;application/zip&quot;,
      &quot;packaging&quot; : &quot;http://purl.org/net/sword/3.0/package/SimpleZip&quot;
    },
    {
      &quot;@id&quot; : &quot;http://www.swordserver.ac.uk/col1/mydeposit/metadata.mods.xml&quot;,
      &quot;rel&quot; : [&quot;http://purl.org/net/sword/3.0/terms/formattedMetadata&quot;],
      &quot;contentType&quot; : &quot;application/xml&quot;,
      &quot;metadataFormat&quot; : &quot;http://www.loc.gov/mods/v3&quot;
    },
    {
      &quot;@id&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/versions/file1.1.pdf&quot;,
      &quot;rel&quot; : [&quot;http://purl.org/net/sword/3.0/terms/derivedResource&quot;],
      &quot;contentType&quot; : &quot;application/pdf&quot;,
      &quot;dcterms:isReplacedBy&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/file1.pdf&quot;,
      &quot;versionReplacedOn&quot; : &quot;[xsd:dateTime]&quot;
    },
    {
      &quot;@id&quot; : &quot;http://www.myorg.ac.uk/sword3/object1/reference.zip&quot;,
      &quot;rel&quot; : [
        &quot;http://purl.org/net/sword/3.0/terms/byReferenceDeposit&quot;,
        &quot;http://purl.org/net/sword/3.0/terms/originalDeposit&quot;,
        &quot;http://purl.org/net/sword/3.0/terms/fileSetFile&quot;
      ],
      &quot;byReference&quot; : &quot;http://www.otherorg.ac.uk/by-reference/file2.zip&quot;,
      &quot;log&quot; : &quot;Any information on the download, especially if it failed&quot;,
      &quot;eTag&quot; : &quot;...&quot;,
      &quot;status&quot; : &quot;http://purl.org/net/sword/3.0/filestate/ingested&quot;
    }
  ],

  &quot;forwarding&quot; : [
    {
      &quot;@id&quot; : &quot;http://www.otherorg.ac.uk/sword3/object12&quot;,

      &quot;links&quot; : [
        {
          &quot;@id&quot; : &quot;http://www.otherorg.ac.uk/col2/yourdeposit.html&quot;,
          &quot;rel&quot; : [&quot;alternate&quot;],
          &quot;contentType&quot; : &quot;text/html&quot;
        }
      ]
    }
  ]
}
</code></pre>

<p>The fields available are defined as follows:</p>
<p><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>@context</td>
<td>string</td>
<td>The JSON-LD Context for this document<br><br>MUST be present.</td>
</tr>
<tr>
<td>@id</td>
<td>string</td>
<td>The Object-URL for this document<br><br>MUST be present</td>
</tr>
<tr>
<td>@type</td>
<td>string</td>
<td>JSON-LD identifier for the document type<br><br>This field is used to define the type of the document, and in this case should always be 'Status'.  MUST be present.</td>
</tr>
<tr>
<td>actions</td>
<td>object</td>
<td>Container for the list of actions that are available against the object for the client.<br><br>MUST be present</td>
</tr>
<tr>
<td>actions.appendFiles</td>
<td>boolean</td>
<td>Whether the client can issue a request to append one or more files (individually or via a package) to the item<br><br>MUST be present</td>
</tr>
<tr>
<td>actions.appendMetadata</td>
<td>boolean</td>
<td>Whether the client can issue a request to append the metadata of the item<br><br>MUST be present</td>
</tr>
<tr>
<td>actions.deleteFiles</td>
<td>boolean</td>
<td>Whether the client can issue a request to delete files in the item.  This may be a single file or all files.<br><br>MUST be present</td>
</tr>
<tr>
<td>actions.deleteMetadata</td>
<td>boolean</td>
<td>Whether the client can issue a request to delete all the item metadata.<br><br>MUST be present</td>
</tr>
<tr>
<td>actions.deleteObject</td>
<td>boolean</td>
<td>Whether the client can issue a request to delete the entire object.<br><br>MUST be present.</td>
</tr>
<tr>
<td>actions.getFiles</td>
<td>boolean</td>
<td>Whether the client can issue a request to retrieve any/all files in the item (both Binary Files and Packaged Content)<br><br>MUST be present</td>
</tr>
<tr>
<td>actions.getMetadata</td>
<td>boolean</td>
<td>Whether the client can issue a request to retrieve the item metadata<br><br>MUST be present</td>
</tr>
<tr>
<td>actions.replaceFiles</td>
<td>boolean</td>
<td>Whether the client can issue a request to replace files in an item.  This may be a single file or all of the files.<br><br>MUST be present</td>
</tr>
<tr>
<td>actions.replaceMetadata</td>
<td>boolean</td>
<td>Whether the client can issue a request to replace the item metadata.<br><br>MUST be present</td>
</tr>
<tr>
<td>eTag</td>
<td>string</td>
<td>The current ETag for the Object<br><br>MUST be present if the repository enforces concurrency control</td>
</tr>
<tr>
<td>fileSet</td>
<td>object</td>
<td>Information about the identifier/version of the Object's FileSet<br><br>MUST be present.</td>
</tr>
<tr>
<td>fileSet.@id</td>
<td>string</td>
<td>The FileSet-URL for this Object<br><br>MUST be present.</td>
</tr>
<tr>
<td>fileSet.eTag</td>
<td>string</td>
<td>The Etag for the FileSet<br><br>MUST be present if the server supports concurrency control</td>
</tr>
<tr>
<td>forwarding</td>
<td>array</td>
<td>List of other locations where the object is available.<br><br>MAY be present</td>
</tr>
<tr>
<td>forwarding[].@id</td>
<td>string</td>
<td>The SWORD identifier for the Object in the other system<br><br>MAY be present</td>
</tr>
<tr>
<td>forwarding[].links</td>
<td>array</td>
<td>List of links to the Object as it appears in the other system<br><br>MAY be present</td>
</tr>
<tr>
<td>forwarding[].links[].@id</td>
<td>string</td>
<td>The URL of a representation of the Object in the other system<br><br>MUST be present</td>
</tr>
<tr>
<td>forwarding[].links[].contentType</td>
<td>string</td>
<td>The Content Type of the resource<br><br>MAY be present</td>
</tr>
<tr>
<td>forwarding[].links[].rel</td>
<td>array</td>
<td>The relationship to the Object that this URL has<br><br>MAY be present</td>
</tr>
<tr>
<td>links</td>
<td>array</td>
<td>List of link objects referring to the various files, both content and metadata, available on the object<br><br>MUST be present if there is one or more links available to the client</td>
</tr>
<tr>
<td>links[].@id</td>
<td>string</td>
<td>The URL of the resource<br><br>MUST be present</td>
</tr>
<tr>
<td>links[].byReference</td>
<td>string</td>
<td>The external URL of the location a By-Reference deposit was retrieved from<br><br>SHOULD be present if this is an Original Deposit that was deposited By-Reference, or is an active By-Reference deposit</td>
</tr>
<tr>
<td>links[].contentType</td>
<td>string</td>
<td>Content type of the resource<br><br>SHOULD be present</td>
</tr>
<tr>
<td>links[].dcterms:isReplacedBy</td>
<td>string</td>
<td>URL to a newer version of the file in the same Object, if this is present as a resource<br><br>SHOULD be present, if newer version is present</td>
</tr>
<tr>
<td>links[].dcterms:relation</td>
<td>string</td>
<td>URL to a non-sword access point to the file<br><br>MAY be present.  For example, the URL from which an end-user would download the file via the website.  This related URL does not need to support any of the SWORD protocol operations, and indeed may even be on a server or application which has no sword support.  Primary use case is to redirect the user to the web front end for the repository.</td>
</tr>
<tr>
<td>links[].dcterms:replaces</td>
<td>string</td>
<td>URL to an older version of the file in the same Object, if this is also present as a resource.<br><br>SHOULD be present, if an older version of the file is present</td>
</tr>
<tr>
<td>links[].depositedBy</td>
<td>string</td>
<td>Identifier for the user that deposited the item<br><br>SHOULD be present if this is an Original Deposit</td>
</tr>
<tr>
<td>links[].depositedOn</td>
<td>string</td>
<td>Timestamp of when the deposit happened<br><br>SHOULD be present if this is an Original Deposit. If present, MUST be formatted as UTC big-endian date as per [<a href="#note-datetime">NOTE-datetime</a>].</td>
</tr>
<tr>
<td>links[].depositedOnBehalfOf</td>
<td>string</td>
<td>Identifier for the user that the item was deposited on behalf of.<br><br>SHOULD be present if this is an Original Deposit that was done On-Behalf-Of another user</td>
</tr>
<tr>
<td>links[].derivedFrom</td>
<td>string</td>
<td>Reference to URL of resource from which the current resource was derived, for example, if extracted from a package that was deposited.<br><br>SHOULD be present, if the resource is derived from another resource</td>
</tr>
<tr>
<td>links[].eTag</td>
<td>string</td>
<td>The eTag of the resource<br><br>MUST be present if the server supports concurrency control and the resource is available to the client to modify</td>
</tr>
<tr>
<td>links[].log</td>
<td>string</td>
<td>Any information associated with the deposit that the client should know.<br><br>MAY be present</td>
</tr>
<tr>
<td>links[].packaging</td>
<td>string</td>
<td>The package format identifier if the resource is a package.<br><br>SHOULD, if the resource is a package</td>
</tr>
<tr>
<td>links[].rel</td>
<td>array</td>
<td>The relationship between the resource and the object.<br><br>MUST be present. Note that multiple relationships are supported.</td>
</tr>
<tr>
<td>links[].status</td>
<td>string</td>
<td>The status of the resource, with regard to ingest.<br><br>SHOULD be present.  For example, packaged resources which are still being unpacked and ingested may announce their status here.  Likewise, by-reference deposits may do the same.  MUST be one of the allowed status URIs.  Any associated information to go along with the status, especially if the status is an error, SHOULD be in link[].log.  If no value is provided, the client MUST assume that the item is in the status: http://purl.org/net/sword/3.0/filestate/ingested</td>
</tr>
<tr>
<td>links[].versionReplacedOn</td>
<td>string</td>
<td>Date that the current resource was replaced by a newer resource<br><br>SHOULD be present if dcterms:isReplacedBy is present</td>
</tr>
<tr>
<td>metadata</td>
<td>object</td>
<td>Information about the identifier/version of the Object's Metadata<br><br>MUST be present if the server permits any operations on metadata.</td>
</tr>
<tr>
<td>metadata.@id</td>
<td>string</td>
<td>The Metadata-URL for this Object<br><br>MUST be present if the server permits any operations on metadata</td>
</tr>
<tr>
<td>metadata.eTag</td>
<td>string</td>
<td>The ETag for the Metadata<br><br>MUST be present if the server supports concurrency control and the Metadata-URL is present</td>
</tr>
<tr>
<td>service</td>
<td>string</td>
<td>The URL for the service to which this item was deposited (the Service-URL)<br><br>MUST be present.  This is the URL from which the client can retrieve information about the settings for the server that are relevant to this item (e.g. max upload sizes, etc)</td>
</tr>
<tr>
<td>state</td>
<td>array</td>
<td>List of states that the item is in on the server.<br><br>At least one state MUST be present, using the SWORD state vocabulary.  Other states using server-specific vocabularies may also be used alongside.</td>
</tr>
<tr>
<td>state[].@id</td>
<td>string</td>
<td>Identifier for the state.<br><br>MUST be present.  At least one such identifier MUST be from the SWORD state vocabulary.</td>
</tr>
<tr>
<td>state[].description</td>
<td>string</td>
<td>Human readable description of the state<br><br>MAY be present</td>
</tr>
</tbody>
</table></p>
<h3><a name="6.6.1"></a>6.6.1. Available <code>rel</code> types and their meanings</h3>
<p><h4>alternate</p></h4>
<p><p>An alternate, non-SWORD URL which will allow the user to access the same object.  For example, this could be the URL of the landing page in the repository for the item.</p>
<h4>http://purl.org/net/sword/3.0/terms/originalDeposit</h4>
<p>The resource (file or package) was explicitly deposited via some deposit operation.</p>
<p>The relevant properties of the link section for any resource with this rel are</p>
<ul>
<li>packaging</li>
<li>depositedOn</li>
<li>depositedOnBehalfOf</li>
<li>status</li>
<li>log</li>
<li>dcterms:relation</li>
<li>dcterms:replaces</li>
<li>dcterms:isReplacedBy</li>
<li>versionReplaced</li>
<li>eTag</li>
<li>byReference</li>
</ul>
<h4>http://purl.org/net/sword/3.0/terms/derivedResource</h4>
<p>A file which was unpacked or otherwise derived from another deposited resource, and which itself was not explicitly deposited through some deposit operation.  The main usage would be to identify files which were extracted from a deposited zip file.</p>
<p>The relevant properties of the link section for any resource with this rel are</p>
<ul>
<li>derivedFrom</li>
<li>dcterms:relation</li>
<li>dcterms:replaces</li>
<li>dcterms:isReplacedBy</li>
<li>versionReplaced</li>
<li>eTag</li>
</ul>
<h4>http://purl.org/net/sword/terms/packagedContent</h4>
<p>A resource which makes this object available packaged in the specified package format on HTTP GET.  This is not a resource which has been deposited or derived (though it may be very similar to an originally deposited package), it is one which the server makes available as a service to the client.  Packages may be pre-built or assembled on the fly - that responsibility rests with the server.</p>
<p>The relevant properties of the link section for any resource with this rel are</p>
<ul>
<li>packaging</li>
</ul>
<h4>http://purl.org/net/sword/3.0/terms/formattedMetadata</h4>
<p>A resource which makes this objects metadata available, serialised in the specified metadata format on HTTP GET.  This is not a resource which has been deposited or derived (though it may be very similar to the originally deposited metadata), it is one which the server makes available as a service to the client.  Metadata documents may be pre-built or assembled on the fly - that responsibility rests with the server.</p>
<p>The relevant properties of the link section for any resource with this rel are</p>
<ul>
<li>metadataFormat</li>
</ul>
<h4>http://purl.org/net/sword/3.0/terms/byReferenceDeposit</h4>
<p>A file which is currently being downloaded from an external reference.  Often will also have the rel for originalDeposit, and once all segments have been uploaded the byReferenceDeposit rel can be removed.</p>
<p>The relevant properties of the link section for any resource with this rel are</p>
<ul>
<li>byReference</li>
<li>status</li>
</ul>
<h4>http://purl.org/net/sword/3.0/terms/fileSetFile</h4>
<p>A File which can be considered by the client to be part of the FileSet.  Files in this state are available for modification via the SWORD protocol, and should be considered to form the actual "content" of the Object.</p>
<p></p></p>
<h3><a name="6.6.2"></a>6.6.2. Required SWORD State Information</h3>
<p><code>state/@id</code> MUST contain one of:</p>
<dl><dt><a name="http://purl.org/net/sword/3.0/state/accepted"></a>http://purl.org/net/sword/3.0/state/accepted</dt><dd>for records accepted for processing but not yet created</dd><dt><a name="http://purl.org/net/sword/3.0/state/inprogress"></a>http://purl.org/net/sword/3.0/state/inProgress</dt><dd>for records that have been deposited, but for which the deposit has not yet completed</dd><dt><a name="http://purl.org/net/sword/3.0/state/inworkflow"></a>http://purl.org/net/sword/3.0/state/inWorkflow</dt><dd>for records that are in the servers ingest workflow</dd><dt><a name="http://purl.org/net/sword/3.0/state/ingested"></a>http://purl.org/net/sword/3.0/state/ingested</dt><dd>for records that are in the servers archive state, whatever that might mean (e.g. published to the web)</dd><dt><a name="http://purl.org/net/sword/3.0/state/rejected"></a>http://purl.org/net/sword/3.0/state/rejected</dt><dd>for records that have been rejected from the servers workflow</dd><dt><a name="http://purl.org/net/sword/3.0/state/deleted"></a>http://purl.org/net/sword/3.0/state/deleted</dt><dd>for tombstone records</dd></dl>

<p>The state field is a list, so it may also contain other states that are server-specific in addition to the SWORD values.</p>
<h3><a name="6.6.3"></a>6.6.3. Ingest Statuses for Individual Files</h3>
<p>Some files, when deposited, may be processed asynchronously to the clients request.  For example, large files that require unpacking, 
by-reference deposits, etc.  In these cases, the client will not receive feedback on the state or success of their 
deposit in the request/response exchange.  Instead, the client may monitor the file(s) via the Status document, and for each appropriate 
file (Original Deposits), a status field will provide information on the current status of processing for that file.  </p>
<p>The following statuses are permitted, servers SHOULD provide one of these by each relevant file:</p>
<dl><dt><a name="http://purl.org/net/sword/3.0/filestate/pending"></a>http://purl.org/net/sword/3.0/filestate/pending</dt><dd>the server has not yet started to process this file. It may be in a queue, or it may still be in the process of deposit via a Segmented Upload.</dd><dt><a name="http://purl.org/net/sword/3.0/filestate/downloading"></a>http://purl.org/net/sword/3.0/filestate/downloading</dt><dd>the server has started to download your By-Reference file, and is not yet complete</dd><dt><a name="http://purl.org/net/sword/3.0/filestate/unpacking"></a>http://purl.org/net/sword/3.0/filestate/unpacking</dt><dd>the server has started unpacking your Packaged Content, and is not yet finished</dd><dt><a name="http://purl.org/net/sword/3.0/filestate/error"></a>http://purl.org/net/sword/3.0/filestate/error</dt><dd>there was an error either downloading or unpacking your file; information should be available in the log field to aid the client in understanding what went wrong.</dd><dt><a name="http://purl.org/net/sword/3.0/filestate/ingested"></a>http://purl.org/net/sword/3.0/filestate/ingested</dt><dd>the file has been successfully ingested</dd></dl>

<h2><a name="6.7"></a>6.7. Segmented File Upload Document</h2>
<p>A client may request information on an ongoing Segmented File Upload at any point via a GET to the Temporary-URL.</p>
<p>The full JSON Schema [<a href="#json-schema">JSON-SCHEMA</a>] can be downloaded <a href="/segmented-file-upload.schema.json">here</a>.</p>
<p>An example of the Segmented File Upload Document:</p>
<pre><code class="json">{
    &quot;@context&quot;: &quot;https://swordapp.github.io/swordv3/swordv3.jsonld&quot;,
    &quot;@id&quot;: &quot;http://example.com/temporary/1&quot;,
    &quot;@type&quot;: &quot;Temporary&quot;,

    &quot;segments&quot;: {
        &quot;received&quot;: [
            1,
            2,
            4
        ],
        &quot;expecting&quot;: [
            3,
            5
        ],
        &quot;size&quot;: 10000000,
        &quot;segment_size&quot;: 2000000
    }
}
</code></pre>

<p>The fields available are defined as follows:</p>
<p><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>@context</td>
<td>string</td>
<td>The JSON-LD Context for this document<br><br>MUST be present.</td>
</tr>
<tr>
<td>@id</td>
<td>string</td>
<td>The Temporary-URL for this document<br><br>MUST be present</td>
</tr>
<tr>
<td>@type</td>
<td>string</td>
<td>JSON-LD identifier for the document type<br><br>This field is used to define the type of the document, and in this case should always be 'Temporary'.  MUST be present.</td>
</tr>
<tr>
<td>segments</td>
<td>object</td>
<td>Container for information on file segments<br><br>MUST be present</td>
</tr>
<tr>
<td>segments.expecting</td>
<td>array</td>
<td>This list of integers identifying the segments which are expected and that have not yet been deposited<br><br>MUST be present if there are any segments remaining to be uploaded</td>
</tr>
<tr>
<td>segments.received</td>
<td>array</td>
<td>The list of integers identifying the segments that have been successfully uploaded so far.<br><br>MUST be present if one or more segments have been uploaded</td>
</tr>
<tr>
<td>segments.segment_size</td>
<td>integer</td>
<td>The expected size in bytes of the segments (except the final one) that will be uploaded.<br><br>MUST be present.</td>
</tr>
<tr>
<td>segments.size</td>
<td>integer</td>
<td>The expected size in bytes of the final resulting assembled file.<br><br>MUST be present.</td>
</tr>
</tbody>
</table></p>
<h2><a name="6.8"></a>6.8. Error Document</h2>
<p>An error document is returned at any point that a synchronous operation fails.</p>
<p>The full JSON Schema [<a href="#json-schema">JSON-SCHEMA</a>] can be downloaded <a href="/error.schema.json">here</a>.</p>
<p>An example of the Error Document:</p>
<pre><code class="json">{
  &quot;@context&quot; : &quot;https://swordapp.github.io/swordv3/swordv3.jsonld&quot;,

  &quot;@type&quot; : &quot;BadRequest&quot;,

  &quot;timestamp&quot; : &quot;[timestamp]&quot;,
  &quot;error&quot; : &quot;error summary&quot;,
  &quot;log&quot; : &quot;text log of any debug information for the client&quot;
}
</code></pre>

<p>The fields available are defined as follows:</p>
<p><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>@context</td>
<td>string</td>
<td>The JSON-LD Context for this document<br><br>MUST be present</td>
</tr>
<tr>
<td>@type</td>
<td>string</td>
<td>JSON-LD identifier for the document type<br><br>This field is used to define the type of the document, and in this case should be one of the allowed Error Doucment types.  MUST be present.</td>
</tr>
<tr>
<td>error</td>
<td>string</td>
<td>A short summary/title for the error<br><br>MUST be present</td>
</tr>
<tr>
<td>log</td>
<td>string</td>
<td>Some detail as to the error, with any information that might help resolve it.<br><br>SHOULD be present</td>
</tr>
<tr>
<td>timestamp</td>
<td>string</td>
<td>When the error occurred. MUST be formatted as UTC big-endian date as per [<a href="#note-datetime">NOTE-datetime</a>].<br><br>MUST be present</td>
</tr>
</tbody>
</table></p>
<h3><a name="6.8.1"></a>6.8.1. Error Types</h3>
<p>The following are the error types that are available (to place in <code>@type</code>), their associated HTTP Status Code, and the legitimate reasons
for returning that error:</p>
<p><table>
<thead>
<tr>
<th>Error Type</th>
<th>Error Code</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>AuthenticationFailed</td>
<td>403</td>
<td>The request supplied invalid credentials</td>
</tr>
<tr>
<td>AuthenticationRequired</td>
<td>401</td>
<td>The request supplied no credentials, when the server was expecting to authenticate the request.</td>
</tr>
<tr>
<td>BadRequest</td>
<td>400</td>
<td>The request did not meet the standard specified by the SWORD protocol. This error can be used when no other error is appropriate</td>
</tr>
<tr>
<td>ByReferenceFileSizeExceeded</td>
<td>400</td>
<td>The client supplied a By-Reference deposit file, which specified a file size which exceeded the server's limit</td>
</tr>
<tr>
<td>ByReferenceNotAllowed</td>
<td>412</td>
<td>The client attempted to carry out a By-Reference deposit on a server which does not support it</td>
</tr>
<tr>
<td>ContentMalformed</td>
<td>400</td>
<td>The body content of the request was malformed in some way, such that the server cannot read it correctly.</td>
</tr>
<tr>
<td>ContentTypeNotAcceptable</td>
<td>415</td>
<td>The <code>Content-Type</code> header specifies a content type of the request which is in a format that the server cannot accept.</td>
</tr>
<tr>
<td>DigestMismatch</td>
<td>412</td>
<td>One or more of the Digests that the server checked did not match the deposited content</td>
</tr>
<tr>
<td>ETagNotMatched</td>
<td>412</td>
<td>The client supplied an <code>If-Match</code> header which did not match the current <code>ETag</code> for the resource being updated.</td>
</tr>
<tr>
<td>ETagRequired</td>
<td>412</td>
<td>The client did not supply an <code>If-Match</code> header, when one was required by the server</td>
</tr>
<tr>
<td>Forbidden</td>
<td>403</td>
<td>The client requested an operation that is not permitted by the server in this context.</td>
</tr>
<tr>
<td>FormatHeaderMismatch</td>
<td>415</td>
<td>The <code>Metadata-Format</code> or <code>Packaging</code> header does not match what the server found when looking at the Metadata or Packaged Content supplied in a request.</td>
</tr>
<tr>
<td>InvalidSegmentSize</td>
<td>400</td>
<td>The client sent a segment that was not the final segment, and was not the size that it indicated segments would be</td>
</tr>
<tr>
<td>MaxAssembledSizeExceeded</td>
<td>400</td>
<td>During a segmented upload initialisation, the client specified a total file size which is larger than the maximum assembled file size supported by the server</td>
</tr>
<tr>
<td>MaxUploadSizeExceeded</td>
<td>413</td>
<td>The request supplied body content which is larger than that supported by the server.</td>
</tr>
<tr>
<td>MetadataFormatNotAcceptable</td>
<td>415</td>
<td>The <code>Metadata-Format</code> header specifies a metadata format for the request which is in a format that the server cannot accept</td>
</tr>
<tr>
<td>MethodNotAllowed</td>
<td>405</td>
<td>The request is for a method on a resource that is not permitted. This may be permanent, temporary, and may depend on the clients credentials</td>
</tr>
<tr>
<td>OnBehalfOfNotAllowed</td>
<td>412</td>
<td>The request contained an <code>On-Behalf-Of</code> header, although the server indicates that it does not support this.</td>
</tr>
<tr>
<td>PackagingFormatNotAcceptable</td>
<td>415</td>
<td>The <code>Packaging</code> header specifies a packaging format for the request which is in a format that the server cannot accept</td>
</tr>
<tr>
<td>SegmentedUploadNotAllowed</td>
<td>412</td>
<td>The client attempted to carry out a Segmented Upload on a server which does not support it</td>
</tr>
<tr>
<td>SegmentedUploadTimedOut</td>
<td>405</td>
<td>The client's segmented upload URL has timed out.  Servers MAY respond to this with a 404 and no explanation also.</td>
</tr>
<tr>
<td>SegmentLimitExceeded</td>
<td>400</td>
<td>During a segmented upload initialisation, the client specified a total number of intended segments which is larger than the limit specified by the server</td>
</tr>
<tr>
<td>UnexpectedSegment</td>
<td>400</td>
<td>The client sent a segment that the server was not expecting; in particular the server may have recieved all the segments it was expecting, and this is an extra one</td>
</tr>
<tr>
<td>ValidationFailed</td>
<td>400</td>
<td>The server could not validate the structure of the incoming content against its expected schema.  This may include the JSON schema of the SWORD documents, the metadata held within those documents, or the expected structure of packaged content.</td>
</tr>
</tbody>
</table></p>
        <h1><a name="7"></a>7. Authentication and Authorisation</h1>
<p>It is strongly RECOMMENDED that SWORD servers support authentication and authorisation for requests.</p>
<p>SWORD servers are not restricted in the forms of authentication that they employ, and there is no minimum requirement or default supported 
approach.</p>
<h2><a name="7.1"></a>7.1. Announcing Support for Authentication Schemes</h2>
<p>Servers SHOULD enumerate the authentication schemes that they support in the Service Document, in the field <code>authentication</code>, and MUST draw 
from the IANA registry of HTTP auth scheme names [<a href="#iana_auth">IANA Auth</a>] where one is available.</p>
<p>Where an authentication scheme is in use by the server which is not covered by the IANA registry - such as a custom API-token-based 
approach, the server MAY indicate this in whatever way seems most appropriate.</p>
<p>For example, a Server which supports Basic, Digest and OAuth authentication, as well as a custom API-Key approach could indicate as follows:</p>
<pre><code class="json">{
  &quot;authentication&quot;: [
    &quot;Basic&quot;,
    &quot;OAuth&quot;,
    &quot;Digest&quot;,
    &quot;APIKey&quot;
  ]
}
</code></pre>

<p>Servers MAY also choose to support On-Behalf-Of deposit, which means that the authenticating user is providing content to the server, as 
if another user were actually carrying out this request.  A use case for this would be when a known third-party deposit tool is sending 
content to a server and has been authorised by another user to add content on their behalf.</p>
<p>If a server supports On-Behalf-Of deposit, it SHOULD indicate this in the Service Document with the field <code>onBehalfOf</code> set to <code>true</code>. 
If this field is not present clients MUST assume that the server does not support On-Behalf-Of deposit.</p>
<pre><code class="json">{
  &quot;onBehalfOf&quot;: true
}
</code></pre>

<h2><a name="7.2"></a>7.2. Authentication and Authorisation in requests</h2>
<p>When carrying out authenticated requests, Authorization headers MUST be sent with every request to the server - the server is not 
responsible for maintaining state for the client.  The server is responsible for authenticating and authorising every request individually. 
Clients may choose also to send <code>Cookie</code> headers, and servers may support these, but support for Cookies is explicitly outside this 
specification.</p>
<p>When an On-Behalf-Of deposit is received, the server MUST ensure that the user identified in that header is valid with respect to the 
associated Authorization header.  For example, when using OAuth2, the On-Behalf-Of user MUST match the user for which the token in the 
Authorization header was granted.</p>
<h2><a name="7.3"></a>7.3. Authentication and Authorisation responses</h2>
<p>There are two possible error responses to a request from the perspective of authentication:</p>
<ol>
<li>
<p>If the request does not supply any credentials, and the server is expecting to authenticate requests, then a <code>401</code> 
(AuthenticationRequired) response MUST be returned.</p>
</li>
<li>
<p>If the request contains credentials and the server is unable to authenticate the client based on those credentials,
then a <code>403</code> (AuthenticationFailed) response MUST be returned.</p>
</li>
</ol>
<h2><a name="7.4"></a>7.4. Recording Depositing Users</h2>
<p>In all cases (On-Behalf-Of or not) where a user has authenticated to make a deposit, servers SHOULD preserve the user's identity in the 
<code>depositedBy</code> property of the Original Deposit in the Status document. In On-Behalf-Of deposit, the value given in the <code>On-Behalf-Of</code> 
header SHOULD be used for the value of the <code>depositedOnBehalfOf</code> property of the Original Deposit in the Status document.</p>
<p>Note that recording a user's identity in this way does not have to contain enough information for the client to directly identify the
user, and implementers should take note of privacy legislation when choosing what information to expose in these fields.</p>
        <h1><a name="8"></a>8. Content Disposition</h1>
<p>SWORD uses the <code>Content-Disposition</code> header in client requests to indicate to the server information about the payload being delivered. 
Traditionally <code>Content-Disposition</code> is an HTTP response header, but it makes sense in the PUSH context of SWORD to use this as a request 
header.  We follow [<a href="#rfc6266">RFC6266</a>] for its usage.</p>
<p>Implementers should also note [<a href="#rfc5987">RFC5987</a>] if sending filenames which require characters outside the ISO-8859-1 character set.</p>
<p>The general format of a Content-Disposition header is as follows:</p>
<pre><code>Content-Disposition: [disposition type]; [disposition param]=[value]; ...
</code></pre>

<p>The rules below define how to generate the correct Content-Disposition for a given set of Request Conditions. If you are implementing a SWORD client
or server it is <strong>STRONGLY RECOMMENDED</strong> that you work from the <strong><a href="/swordv3-behaviours.html">SWORDv3 Behaviours Document</a></strong>,
as this lays out the <code>Content-Disposition</code> requirements per-request, rather than in the form of the normalised requirements below.</p>
<p>There are three general deposit operations in SWORD:</p>
<ol>
<li>A direct upload of some content, which may be Metadata, a By-Reference document, or a Binary File (which may itself be Packaged Content)</li>
<li>A Segmented Upload Initialisation</li>
<li>A File Segment for a Segmented Upload</li>
</ol>
<p>Each of these has a different <code>Content-Disposition</code>, which makes it clear to the server what it should do with that content.</p>
<p>There are two aspects which control what the Content-Disposition should be:</p>
<ul>
<li>The Upload Type</li>
<li>The Content</li>
</ul>
<p>The requirements below define what <em>Disposition Type</em> and <em>Parameters</em> are required for each kind of request.  The requirements should be
interpreted according to the following hierarchy for each of the above aspects:</p>
<p>The hierarchy for the Upload Type is:</p>
<ul>
<li>All<ul>
<li>Segmented Upload Initialisation</li>
<li>Direct Deposit</li>
<li>File Segment Upload</li>
</ul>
</li>
</ul>
<p>The hierarchy for the Content is:</p>
<ul>
<li>All<ul>
<li>Empty Body</li>
<li>Body<ul>
<li>JSON<ul>
<li>Metadata</li>
<li>By-Reference</li>
<li>MD+BR</li>
</ul>
</li>
<li>Binary<ul>
<li>Binary File</li>
<li>Packaged Content</li>
<li>File Segment</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>So, for example, if delivering a Metadata+By-Reference Document (MD+BR) as a Direct Deposit, you would take into account the following
requirements:</p>
<ul>
<li>With an Upload Type of Direct Deposit: <strong>Direct Deposit</strong> and <strong>All</strong></li>
<li>With a Content type of MD+BR: <strong>MD+BR</strong>, <strong>JSON</strong>, <strong>Body</strong> and <strong>All</strong></li>
</ul>
<p>The requirements are:</p>
<p><p><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Upload Type</strong>: Direct Deposit</li>
<li><strong>Content</strong>: All</li>
</ul>
<p><strong>Disposition Type</strong></p>
<ul>
<li>attachment</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Upload Type</strong>: Direct Deposit</li>
<li><strong>Content</strong>: Metadata</li>
</ul>
<p><strong>Param</strong></p>
<ul>
<li>metadata=true - Indicates that the body content of the request contains Metadata.  A Direct Deposit containing Metadata MUST contain this parameter.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Upload Type</strong>: Direct Deposit</li>
<li><strong>Content</strong>: By-Reference</li>
</ul>
<p><strong>Param</strong></p>
<ul>
<li>by-reference=true - Indicates that the body content of the request contains By-Reference files.  A Direct Deposit containing By-Reference files MUST contain this parameter.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Upload Type</strong>: Direct Deposit</li>
<li><strong>Content</strong>: MD+BR</li>
</ul>
<p><strong>Param</strong></p>
<ul>
<li>metadata=true - Indicates that the body content of the request contains Metadata.  A Direct Deposit containing Metadata MUST contain this parameter.</li>
<li>by-reference=true - Indicates that the body content of the request contains By-Reference files.  A Direct Deposit containing By-Reference files MUST contain this parameter.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Upload Type</strong>: Direct Deposit</li>
<li><strong>Content</strong>: Binary File</li>
</ul>
<p><strong>Param</strong></p>
<ul>
<li>filename=[filename] - Indicates the intended filename of the deposited file.  MAY be present, and if present the server SHOULD respect it, unless this is an update to an existing file, then the server MAY ignore this parameter. If using a character set outside of ISO-8859-1, you MUST use <code>filename*</code> instead.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Upload Type</strong>: Direct Deposit</li>
<li><strong>Content</strong>: Packaged Content</li>
</ul>
<p><strong>Param</strong></p>
<ul>
<li>filename=[filename] - Indicates the intended filename of the deposited file.  MAY be present, and if present the server SHOULD respect it, unless this is an update to an existing file, then the server MAY ignore this parameter. If using a character set outside of ISO-8859-1, you MUST use <code>filename*</code> instead.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Upload Type</strong>: Segmented Upload Initialisation</li>
<li><strong>Content</strong>: Empty Body</li>
</ul>
<p><strong>Disposition Type</strong></p>
<ul>
<li>segment-init</li>
</ul>
<p><strong>Param</strong></p>
<ul>
<li>size=[bytes] - The total size of the final file.  This MUST be sent so that the server can determine when all the bytes of the file have been uploaded.</li>
<li>digest=[digest] - The Digest information for the resulting file as a whole, after assembly.  This MUST be present, and MUST be in the same form as if it were the HTTP header you would use if depositing this file as a whole.</li>
<li>segment_count=[n] - The total number of segments that will be sent to the Temporary-URL.  This MUST be present. Later, any segment uploads with segment_number greater than this number MUST be rejected by the server.</li>
<li>segment_size=[bytes] - The size of each segment (except the final segment) that the client will be sending.  This MUST be present.  If a non-final segment is sent with a different size, this MUST be rejected by the server.</li>
</ul>
<p><hr><strong>Request Conditions</strong>:</p>
<ul>
<li><strong>Upload Type</strong>: File Segment Upload</li>
<li><strong>Content</strong>: File Segment</li>
</ul>
<p><strong>Disposition Type</strong></p>
<ul>
<li>segment</li>
</ul>
<p><strong>Param</strong></p>
<ul>
<li>segment_number=[n] - The position in the full sequence of this segment.  This MUST be present.  It MUST be an integer, and MUST start counting at 1.  Full list of segments MUST be a sequential list of integers.</li>
</ul>
<p><hr></p></p>
<p>The following examples show a number of key cases:</p>
<p><strong>A Metadata Deposit</strong></p>
<pre><code>Content-Disposition: attachment; metadata=true
</code></pre>

<p><strong>A By-Reference Deposit</strong></p>
<pre><code>Content-Disposition: attachment; by-reference=true
</code></pre>

<p><strong>A Metadata+By-Reference Deposit</strong></p>
<pre><code>Content-Disposition: attachment; metadata=true; by-reference=true
</code></pre>

<p><strong>A Binary File Deposit</strong></p>
<pre><code>Content-Disposition: attachment; filename=[filename]
</code></pre>

<p><strong>A Segmented Upload Initialisation</strong></p>
<pre><code>Content-Disposition: segment-init; size=[bytes]; digest=[digest]; segment_count=[n]; segment_size=[bytes]
</code></pre>

<p><strong>A File Segment Upload</strong></p>
<pre><code>Content-Disposition: segment; segment_number=[n]
</code></pre>
        <h1><a name="9"></a>9. Segmented File Upload</h1>
<p>If a client has a very large file that it wishes to transfer to the server by value, then in may be beneficial to do this in several small 
operations, rather than as a single large operation.  Large uploads are at higher risk of failure, depending on a variety of factors, and 
there is no guarantee that a SWORD server will be able to resume a partial upload.</p>
<p>In order to transfer a large file, the client can break it down into a number of equally sized segments of binary data (the final segment 
may be a different size to the rest).  It can then initialise a Segmented File Upload with the server, and then transfer the segments.  The 
server will reconstitute these segments into a single file, and then the client may deposit this file by-reference.</p>
<p>Segments can be uploaded in any order, and can be uploaded one at a time or in parallel.</p>
<h2><a name="9.1"></a>9.1. Announcing Support for Segmented File Upload</h2>
<p>Servers MAY support Segmented File Upload.  To do so, it must provide a staging area where file segments can be uploaded prior to the client
requesting a specific deposit operation.  The server MUST include a <code>staging</code> field in the <a href="#6.2">Service Document</a> with a URL for where
the client can initialise its Segmented File Upload.  It SHOULD also specify how long it will retain an unfinished Segmented File Upload, before 
assuming that the client will not complete it, with the <code>stagingMaxIdle</code> field:</p>
<pre><code class="json">{
  &quot;stagingMaxIdle&quot;: 3600,
  &quot;staging&quot;: &quot;http://example.com/staging&quot;
}
</code></pre>

<h2><a name="9.2"></a>9.2. Outline of Process for Segmented File Upload</h2>
<ol>
<li>
<p>Obtain the Staging-URL<sup>[<a href="#staging-url">def</a>]</sup> from the Service from which to request an Temporary-URL<sup>[<a href="#temporary-url">def</a>]</sup></p>
<p>If the client is creating a new Object, the Staging-URL can be found in the <code>staging</code> field in the <a href="#6.2">Service Document</a>.  If an Object
already exists, the client should find the Service-URL from the <code>service</code> field in the <a href="#6.2">Service Document</a>, then GET this URL
to obtain the appropriate <a href="#6.2">Service Document</a>, and subsequently get the Staging-URL from the <code>staging</code> field.</p>
</li>
<li>
<p>Request a Temporary-URL<sup>[<a href="#temporary-url">def</a>]</sup> from the Service, via a <a href="#9.3">Segmented Upload Initialisation</a> request.</p>
<p>Send a POST request to the Staging-URL, as per <a href="#4.3.15">POST Staging-URL</a>, with the appropriate <code>Content-Disposition</code> (see below).  The
server will respond with a Temporary-URL in the <code>Location</code> header.</p>
</li>
<li>
<p>Upload all the file segments to the Temporary-URL<sup>[<a href="#temporary-url">def</a>]</sup></p>
<p>Send one or more POST requests to the Temporary-URL as per <a href="#4.3.17">POST Temporary-URL</a>, with the appropriate <code>Content-Disposition</code> (see 
below), until all file segments have been uploaded.</p>
</li>
<li>
<p>Carry out the desired deposit operation as a By-Reference deposit, using the Temporary-URL as the by-reference file.</p>
<p>Refer to the section {% mdinline %}{% autoescape off %}{{ section_link("By-Reference Deposit", "main") }}{% endautoescape %}{% endmdinline %} for more information on this approach.  Deposits of content hosted at Temporary-URLs SHOULD NOT
contain the <code>ttl</code> or <code>dereference</code> fields in the By-Reference Document, and if they are included, the server MUST ignore them.</p>
</li>
</ol>
<h2><a name="9.3"></a>9.3. Segmented Upload Initialisation</h2>
<p>Before sending any segments to the server, the client must initialise the process.  This is done by sending a POST request to the
Staging-URL as per <a href="#4.3.15">POST Staging-URL</a>.</p>
<p>The requirements of the protocol for a Segment Upload Initialisation are:</p>
<p><p><strong>Protocol Operation</strong></p>
<ul>
<li>POST Staging-URL</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY specify <code>Authorization</code> and <code>On-Behalf-Of</code> headers (i.e. if authenticating this request)</li>
<li>MUST provide the <code>Content-Disposition</code> header, with the appropriate value for the request</li>
<li>MAY provide the <code>Content-Length</code> header with value <code>0</code></li>
<li>MUST NOT include any body content</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If <code>Authorization</code> (and optionally <code>On-Behalf-Of</code>) headers are provided, MUST authenticate the request</li>
<li>If all preconditions are met, MUST create a resource to which the client can upload file segments</li>
<li>MUST reject the request if the conditions of the upload are not acceptable</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>If no authentication credentials were supplied, but were expected, MUST respond with a <code>401</code> (AuthenticationRequired)</li>
<li>If authentication fails with supplied credentials, MUST respond with a <code>403</code> (AuthenticationFailed)</li>
<li>MUST respond with a <code>201</code> to indicate that the Segmented Upload has been initialised, or raise an error.</li>
<li>MUST respond with a <code>Location</code> header containing the Temporary-URL where the client can upload file segments</li>
</ul>
<p></p></p>
<p>See the section <a href="#8">Content Disposition</a> for detailed information on the <code>Content-Disposition</code> header.  Based on that section, the
supplied <code>Content-Disposition</code> would be:</p>
<pre><code>Content-Disposition: segment-init; size=[bytes]; digest=[digest]; segment_count=[n]; segment_size=[bytes]
</code></pre>

<p>The server MAY choose to reject the Segmented Upload Initialisation request at this stage, for a variety of reasons - for example, it may 
have a limit on the total number of segments it will accept, or the total size may exceed a maximum file size for assembled files.  In 
these cases, the server MUST respond with one of the appropriate <a href="#6.8.1">Error Types</a>.</p>
<p>If the request is successful, the server will respond with a Temporary-URL in the <code>Location</code> header, and the segments themselves can be
uploaded to that URL.</p>
<h2><a name="9.4"></a>9.4. Uploading File Segments</h2>
<p>Segments may be uploaded in any order and may also be parallelised.  Segments MUST all be the same size, with the exception of the final 
segment with MUST be the same size or smaller than the other segments.  Segments size MUST be smaller than the <code>maxSegmentSize</code> if specified
and if not then smaller than <code>maxUploadSize</code> specified in the <a href="#6.2">Service Document</a>. Segments MUST be larger than the <code>minSegmentSize</code>
also specified in the <a href="#6.2">Service Document</a>.</p>
<p>The requirements of the protocol for File Segment Upload are:</p>
<p><p><strong>Protocol Operation</strong></p>
<ul>
<li>POST Temporary-URL</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY specify <code>Authorization</code> and <code>On-Behalf-Of</code> headers (i.e. if authenticating this request)</li>
<li>MUST provide the <code>Content-Disposition</code> header, with the appropriate value for the request</li>
<li>MUST provide the <code>Digest</code> header</li>
<li>SHOULD provide the <code>Content-Length</code></li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If <code>Authorization</code> (and optionally <code>On-Behalf-Of</code>) headers are provided, MUST authenticate the request</li>
<li>MUST verify that the content matches the <code>Digest</code> header</li>
<li>MUST verify that the supplied content matches the <code>Content-Length</code> if this is provided</li>
<li>MUST reject the request if the segment is incorrect or unexpected: for example, all segments were already received, or the segment is a different size than expected.</li>
<li>If all preconditions are met, MUST accept the file segment, and record the receipt of it</li>
<li>MUST be prepared to accept file segments in any order, and in parallel</li>
<li>MUST be able to store the incoming file segments as they arrive, and then reconstitute them into a single file when all segments have been received.</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>If no authentication credentials were supplied, but were expected, MUST respond with a <code>401</code> (AuthenticationRequired)</li>
<li>If authentication fails with supplied credentials, MUST respond with a <code>403</code> (AuthenticationFailed)</li>
<li>MUST respond with a <code>204</code> or a suitable error</li>
</ul>
<p></p></p>
<p>See the section <a href="#8">Content Disposition</a> for detailed information on the <code>Content-Disposition</code> header.  Based on that section, the
supplied <code>Content-Disposition</code> would be:</p>
<pre><code>Content-Disposition: segment; segment_number=[n]
</code></pre>

<p>The <code>Content-Type</code> header MUST just be <code>application/octet-stream</code>.</p>
<p>The <code>Digest</code> header MUST contain the Digest for the File Segment itself, so the server can confirm successful transfer of the segment.</p>
<h2><a name="9.5"></a>9.5. Retrieving Information about a Segmented File Upload</h2>
<p>At any point after creating a Temporary-URL, the client may request information on the state of their Segmented File Upload.  This can
be done via a GET to the Temporary-URL.</p>
<p>This will return you a document as described in <a href="#6.7">Segmented File Upload Document</a>.</p>
<p>The requirements for this operation are:</p>
<p><p><strong>Protocol Operation</strong></p>
<ul>
<li>GET Temporary-URL</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY specify <code>Authorization</code> and <code>On-Behalf-Of</code> headers (i.e. if authenticating this request)</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If <code>Authorization</code> (and optionally <code>On-Behalf-Of</code>) headers are provided, MUST authenticate the request</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>If no authentication credentials were supplied, but were expected, MUST respond with a <code>401</code> (AuthenticationRequired)</li>
<li>If authentication fails with supplied credentials, MUST respond with a <code>403</code> (AuthenticationFailed)</li>
<li>MUST respond with a <code>200</code> or a suitable error</li>
<li>If successful, MUST respond with a Segmented File Upload Document describing the current state of the upload.</li>
</ul>
<p></p></p>
<p><strong>NOTE</strong> that you cannot retrieve an actual copy of the full or partially uploaded Segmented File Upload from the Temporary-URL at any point.</p>
<h2><a name="9.6"></a>9.6. Aborting an Upload</h2>
<p>If, part way through a segmented upload (even after completion) the client wishes to abort, it can send an DELETE request to the 
Temporary-URL, with the following requirements:</p>
<p><p><strong>Protocol Operation</strong></p>
<ul>
<li>DELETE Temporary-URL</li>
</ul>
<p><strong>Request Requirements</strong></p>
<ul>
<li>MAY specify <code>Authorization</code> and <code>On-Behalf-Of</code> headers (i.e. if authenticating this request)</li>
</ul>
<p><strong>Server Requirements</strong></p>
<ul>
<li>If <code>Authorization</code> (and optionally <code>On-Behalf-Of</code>) headers are provided, MUST authenticate the request</li>
</ul>
<p><strong>Response Requirements</strong></p>
<ul>
<li>If no authentication credentials were supplied, but were expected, MUST respond with a <code>401</code> (AuthenticationRequired)</li>
<li>If authentication fails with supplied credentials, MUST respond with a <code>403</code> (AuthenticationFailed)</li>
<li>MUST respond with a <code>204</code> if the delete is successful, <code>202</code> if the delete is queued for processing, or raise an error</li>
</ul>
<p></p></p>
<p>If a client submits the Temporary-URL as a By-Reference deposit to the server after completing the upload, the client SHOULD NOT delete
the Temporary-URL themselves, the server SHOULD take responsibility for this.  If the client deletes the resource before the By-Reference
deposit has completed, the server SHOULD record an error against the ingest.</p>
<h2><a name="9.7"></a>9.7. Incomplete Upload Retention</h2>
<p>Servers SHOULD delete incomplete Segmented File Uploads after a specified amount of time (in the Service Document), if they are not 
finalised with all segments.</p>
<h2><a name="9.8"></a>9.8. Completed Upload Retention</h2>
<p>Servers SHOULD delete completed Segmented File Uploads after a specified amount of time (in the Service Document).  Servers MUST be able to
tell when they have been given one of their own Temporary-URLs as a By-Reference deposit, and not delete that resource until after it has
been ingested.</p>
<h2><a name="9.9"></a>9.9. Errors</h2>
<p>Servers MUST respond with Error documents under the following circumstances (in addition to the standard errors that may arise through using
the protocol):</p>
<ul>
<li>An initialisation request is sent which specifies a total size larger than that allowed by the server (MaxAssembledSizeExceeded)</li>
<li>An initialisation request is sent which specifies a segment size larger than that allowed by the server (MaxUploadSizeExceeded)</li>
<li>An initialisation request is sent which specifies a segment size smaller than that allowed by the server (InvalidSegmentSize)</li>
<li>An initialisation request is sent which specifies a segment count larger than that allowed by the server (SegmentLimitExceeded)</li>
<li>An upload request is sent after the total_size has been reached (MethodNotAllowed)</li>
<li>An upload request is sent after the segment_count has been reached (MethodNotAllowed)</li>
<li>A segment is received which is not the final segment and is not the same as the expected file size (InvalidSegmentSize)</li>
<li>A segment is received which is the final segment which is larger than the other segment sizes (InvalidSegmentSize)</li>
<li>A segment is received which is larger than that allowed by the server (InvalidSegmentSize)</li>
<li>A segment is received which is smaller than that allowed by the server (InvalidSegmentSize)</li>
<li>A segment number is received which is not in the allowed range (SegmentLimitExceeded)</li>
</ul>
<p>The server MAY respond with an Error document under the following circumstances:</p>
<ul>
<li>The Temporary-URL has timed out, and the server will no longer receive updates to it (SegmentedUploadTimedOut)</li>
</ul>
<p>If any other errors occur asynchronously, such as in reassembling or unpacking the resulting file, servers MUST provide an error <code>status</code> 
field and suitable <code>log</code> information in the link record in the Status document.</p>
        <h1><a name="10"></a>10. Metadata Deposit</h1>
<p>SWORD allows the client to deposit arbitrary metadata onto the server through agnostic support for metadata formats.  A metadata format is
any document which expresses metadata in a given serialisation.  SWORD has a default format
which MUST be supported by the server, which consists of the set of DCMI Terms [<a href="#dcmi">DCMI</a>] expressed as JSON (see <a href="#6.3">Metadata Document</a>).</p>
<p>In general, the form of metadata consists of several aspects:</p>
<ol>
<li>
<p>The serialisation, such as to JSON or XML</p>
</li>
<li>
<p>The vocabulary of the metadata, such as Dublin Core, or MODS (sometimes the vocabulary and the serialisation will be conflated here)</p>
</li>
<li>
<p>The profile of the metadata, such as the RIOXX profile for DC (+extensions)</p>
</li>
</ol>
<p>Any format (combining the 3 aspects above) may be represented by an IRI in the protocol, or an opaque string if no IRI exists or can be minted.</p>
<p>SWORD does not require that the server be able to disseminate any metadata in a format other than the default format.  Metadata in the 
default format can be obtained from <a href="#4.3.7">GET Metadata-URL</a>.  If the server chooses to make other metadata formats
available, this SHOULD be listed in the <code>links</code> section of the <a href="#6.6">Status Document</a>.  See 
<a href="#11.3">Representing Other Formats in the Service Document</a> for details.</p>
<h2><a name="10.1"></a>10.1. Announcing Support for Metadata Formats</h2>
<p>The server can list Metadata formats that it will accept in the <code>acceptMetadata</code> field of the <a href="#6.2">Service Document</a>.</p>
<p>If no <code>acceptMetadata</code> field is present, the client MUST assume the server only supports the default SWORD metadata format 
(http://purl.org/net/sword/3.0/types/Metadata).</p>
<pre><code class="json">{
  &quot;acceptMetadata&quot;: [
    &quot;http://purl.org/net/sword/3.0/types/Metadata&quot;
  ]
}
</code></pre>

<h2><a name="10.2"></a>10.2. Indicating Metadata Format to the Server</h2>
<p>During deposit, the client SHOULD specify a <code>Metadata-Format</code> header which contains the identifier for the format.  For example, if 
supplying the default SWORD metadata format:</p>
<pre><code>Metadata-Format: http://purl.org/net/sword/3.0/types/Metadata
</code></pre>

<p>If this header is not present the server MUST assume it has the above value.</p>
        <h1><a name="11"></a>11. Metadata Formats</h1>
<h2><a name="11.1"></a>11.1. Default Format</h2>
<p>In order to provide a baseline of interoperability, SWORD provides a default metadata format which MUST be supported by the server.  This 
document has the following aspects (as per <a href="#10">Metadata Deposit</a>):</p>
<ol>
<li>
<p>It is serialised as JSON and with a JSON-LD <code>@context</code></p>
</li>
<li>
<p>It contains <code>dc</code> and <code>dcterms</code> vocabulary elements, and any other arbitrary elements added by the client</p>
</li>
<li>
<p>It does not pre-suppose any particular profile of usage of these vocabulary elements.</p>
</li>
</ol>
<p>Clients MAY choose to extend this document with their own metadata fields, though the server MAY NOT understand them, and MAY ignore them.</p>
<p>When using this Metadata Format, the client should identify it in the Metadata-Format header with the following IRI:</p>
<pre><code>http://purl.org/net/sword/3.0/types/Metadata
</code></pre>

<h2><a name="11.2"></a>11.2. Depositing Other Formats</h2>
<p>In addition to the standard SWORD metadata format described above, SWORD can support the deposit of arbitrary metadata schemas and 
serialisations.  </p>
<p>Clients who wish to ensure that their servers support all the metadata they send them should consider minting a new identifier for their 
format, and looking for servers to declare explicit support for it.</p>
<p>Clients should not expect that servers will keep their metadata in the format it is provided.  Servers can and will store the metadata
in their internal formats as needed.</p>
<p>The following is a minimal example of the deposit of a MODS XML metadata file while creating a new Object:</p>
<pre><code>POST Service-URL
Content-Type: application/xml
Content-Disposition: attachment; metadata=true
Digest: SHA-256=74b2851bd2760785b0987ba219debea69c228353f7ccc67a2bdcd9819f97fc71
Metadata-Format: http://www.loc.gov/mods/v3

&lt;mods xmlns:mods=&quot;http://www.loc.gov/mods/v3&quot;&gt;
  &lt;originInfo&gt;
    &lt;place&gt;
      &lt;placeTerm type=&quot;code&quot; authority=&quot;marccountry&quot;&gt;nyu&lt;/placeTerm&gt;
      &lt;placeTerm type=&quot;text&quot;&gt;Ithaca, NY&lt;/placeTerm&gt;
    &lt;/place&gt;
    &lt;publisher&gt;Cornell University Press&lt;/publisher&gt;
    &lt;copyrightDate&gt;1999&lt;/copyrightDate&gt;
  &lt;/originInfo&gt;
&lt;/mods&gt;
</code></pre>

<p>If the server supports the MODS Metadata-Format, identified with the IRI <code>http://www.loc.gov/mods/v3</code> then it will be able to create a new 
Object from this XML document, and populate the Metadata from the data therein.</p>
<h2><a name="11.3"></a>11.3. Representing Other Formats in the Service Document</h2>
<p>A server is not required to retain or be able to disseminate the metadata delivered to it by the client in the format it is provided.  Alternative
metadata formats to the default format MAY be accepted (as defined by the <code>acceptMetadata</code> field in the <a href="#6.6">Status Document</a>),
but the server is not required to be able to serve that metadata format as well.</p>
<p>If the server chooses to expose metadata in alternative formats to the default, it may do so by providing them
as links in the <code>links</code> section of the <a href="#6.6">Status Document</a>.  To do this:</p>
<ul>
<li>Provide a link to the serialised metadata</li>
<li>Specify a <code>rel</code> type of <code>http://purl.org/net/sword/3.0/terms/formattedMetadata</code></li>
<li>Specify the <code>contentType</code> as needed</li>
<li>Specify the <code>metadataFormat</code> as the format identifier for the metadata schema.</li>
</ul>
<p>For example, to reflect the metadata from the previous section back to the client:</p>
<pre><code class="json">{
  &quot;metadataFormat&quot;: &quot;http://www.loc.gov/mods/v3&quot;,
  &quot;contentType&quot;: &quot;application/xml&quot;,
  &quot;rel&quot;: [
    &quot;http://purl.org/net/sword/3.0/terms/formattedMetadata&quot;
  ],
  &quot;@id&quot;: &quot;http://www.swordserver.ac.uk/col1/mydeposit/metadata.mods.xml&quot;
}
</code></pre>
        <h1><a name="12"></a>12. Packaging Formats</h1>
<p>There are 3 packaging formats the all SWORD implementations MUST support.</p>
<h2><a name="12.1"></a>12.1. Binary</h2>
<p>URI: http://purl.org/net/sword/3.0/package/Binary</p>
<p>This format indicates that the package should be interpreted as an opaque blob, and the server SHOULD NOT attempt to extract any content 
from it.  This is typically for use when depositing single files, which do not need unpacking of any kind.</p>
<p>Servers MAY choose, nonetheless, to extract content from Binary packages, if they have the capabilities, such as metadata from images, 
structural information from text documents, etc.</p>
<h2><a name="12.2"></a>12.2. SimpleZip</h2>
<p>URI: http://purl.org/net/sword/3.0/package/SimpleZip</p>
<p>This format indicates that the package is a compressed set of one or more files in an arbitrary directory structure.  The nature of the 
compression and the structure of the compressed content is not specified.</p>
<p>Servers MAY choose to extract the content from SimpleZip packages, and present the individual file components as <code>derivedResource</code>s, if 
desired.</p>
<h2><a name="12.3"></a>12.3. SWORDBagIt</h2>
<p>URI: http://purl.org/net/sword/3.0/package/SWORDBagIt</p>
<p>This format is a profile of the BagIt directory structure, which has in turn been serialised (which may include compression).  The nature 
of the serialisation/compression is not specified, though if the client wishes the server to extract the content, it SHOULD use one of
the formats specified in the <a href="#6.2">Service Document</a> field <code>acceptArchiveFormat</code>.</p>
<p>A <a href="/SWORDBagIt.json">SWORD BagIt Profile</a> is available which desribes the outline structure of the bag.</p>
<pre><code>SwordBagIt
| -- bag-info.txt
| -- bagit.txt
| -- data
| -- | -- bitstreams ...
|    \ -- directories ...
|         \ bitstreams ...
| -- manifest-sha-256.txt
| -- metadata
|     \-- sword.json
\ -- tagmanifest-sha-256.txt
</code></pre>

<p>This allows us to represent the item as a combination of an arbitrary structure of bitstreams in the data directory (similar to SimpleZip), 
and the metadata in the sword default format in <code>metadata/sword.json</code>.  A <code>manifest</code> (and <code>tagmanifest</code>) of sha-256 checksums is required, as 
well as the <code>bagit.txt</code> file and a <code>bag-info.txt</code> file.  Note that although listed, the <code>bag-info.txt</code> is not used by SWORD to transfer metadata.  All metadata MUST appear in
<code>metadata/sword.json</code>.</p>
<p>The content of <code>sword.json</code> is exactly as defined in the SWORD default Metadata.  Note that use of <code>fetch.txt</code> is not supported here.</p>
<p>The server SHOULD unpack this file, and action at least the Metadata.  The contents of the data directory MAY be unpackaged into 
<code>derivedResource</code>s if the server desires.  It is RECOMMENDED that the contents of the data directory be a flat file structure, to aid 
mutual comprehension by servers/clients.</p>
        <h1><a name="13"></a>13. Auto-Discovery</h1>
<p>In order to assist potential clients discover a servers capabilities, SWORD RECOMMENDS the following auto-discovery features to be 
embedded in any web interfaces associated with the service provider.</p>
<h2><a name="13.1"></a>13.1. For Services</h2>
<p>Embed an html link with a rel value of <code>http://purl.org/net/sword/3.0/discovery/Service</code> in any page which represents
a deposit Service.</p>
<pre><code>&lt;html:link rel=&quot;http://purl.org/net/sword/3.0/discovery/Service&quot; href=&quot;[Service-URL]&quot;/&gt;
</code></pre>

<h2><a name="13.2"></a>13.2. For Objects</h2>
<p>Embed an html link with a rel value of <code>http://purl.org/net/sword/3.0/discovery/Object</code> in any page which represents a deposited resource.</p>
<pre><code>&lt;html:link rel=&quot;http://purl.org/net/sword/3.0/discovery/Object&quot; href=&quot;[Object-URL]&quot;/&gt;
</code></pre>

<h2><a name="13.3"></a>13.3. Well-Known URI</h2>
<p>For any server which wishes to expose its main or root Service-URL via Well-Known URIs [<a href="#rfc8615">RFC8615</a>], provide a
redirect (307) from <code>./well-known/swordv3</code> (PROVISIONAL) to your root Service-URL.</p>
        <h1><a name="14"></a>14. References</h1>
<p><p><a name="atompub"><strong>AtomPub</strong> Gregario, J. and B. de hOra, "The Atom Publishing Protocol", RFC 5023, October 2007. <a href="http://www.ietf.org/rfc/rfc5023.txt">http://www.ietf.org/rfc/rfc5023.txt</a> </p>
<p><a name="dcmi"><strong>DCMI</strong> DCMI Metadata Terms, 2012-06-14 <a href="http://dublincore.org/documents/dcmi-terms/">http://dublincore.org/documents/dcmi-terms/</a> </p>
<p><a name="iana_auth"><strong>IANA Auth</strong> Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry <a href="https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml">https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml</a> </p>
<p><a name="iana_digest"><strong>IANA Digest</strong> Hypertext Transfer Protocol (HTTP) Digest Algorithm Values <a href="https://www.iana.org/assignments/http-dig-alg/http-dig-alg.xhtml">https://www.iana.org/assignments/http-dig-alg/http-dig-alg.xhtml</a> </p>
<p><a name="json-ld"><strong>JSON-LD</strong> JSON-LD 1.1, A JSON-based Serialization for Linked Data, 28 March 2018 <a href="https://json-ld.org/spec/latest/json-ld/">https://json-ld.org/spec/latest/json-ld/</a> </p>
<p><a name="json-schema"><strong>JSON-SCHEMA</strong> JSON Schema: A Media Type for Describing JSON Documents <a href="http://json-schema.org/latest/json-schema-core.html">http://json-schema.org/latest/json-schema-core.html</a> </p>
<p><a name="note-datetime"><strong>NOTE-datetime</strong> Wolf, M. and Wicksteed, C. "Date and Time Formats", 1997 <a href="https://www.w3.org/TR/NOTE-datetime">https://www.w3.org/TR/NOTE-datetime</a> </p>
<p><a name="openapi"><strong>OpenAPI</strong> OpenAPI Specification, Version 3.0.0 <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md</a> </p>
<p><a name="rfc2119"><strong>RFC2119</strong> Bradner, S. "Key words for use in RFCs to Indicate Requirement Levels", March 1997. <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a> </p>
<p><a name="rfc3230"><strong>RFC3230</strong> J. Mogul et al "Instance Digests in HTTP" <a href="https://www.ietf.org/rfc/rfc3230.txt">https://www.ietf.org/rfc/rfc3230.txt</a> </p>
<p><a name="rfc5987"><strong>RFC5987</strong> J. Reschke. "Character Set and Language Encoding for Hypertext Transfer Protocol (HTTP) Header Field Parameters" <a href="https://tools.ietf.org/html/rfc5987">https://tools.ietf.org/html/rfc5987</a> </p>
<p><a name="rfc6266"><strong>RFC6266</strong> J. Reschke. "Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP)", 2011 <a href="https://tools.ietf.org/html/rfc6266">https://tools.ietf.org/html/rfc6266</a> </p>
<p><a name="rfc7232"><strong>RFC7232</strong> R. Fielding and J. Reschke, "Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests", June 2014 <a href="https://tools.ietf.org/html/rfc7232">https://tools.ietf.org/html/rfc7232</a> </p>
<p><a name="rfc8615"><strong>RFC8615</strong> M Nottingham. "Well-Known Uniform Resource Identifiers (URIs)", 2019 <a href="https://tools.ietf.org/html/rfc8615">https://tools.ietf.org/html/rfc8615</a> </p>
<p><a name="sword_1.3"><strong>SWORD 1.3</strong> Downing, J. "SWORD AtomPub Profile version 1.3", 2008. <a href="http://www.swordapp.org/docs/sword-profile-1.3.html">http://www.swordapp.org/docs/sword-profile-1.3.html</a> </p>
<p><a name="sword_2.0"><strong>SWORD 2.0</strong> Jones, R. and Lewis, S. "SWORD 2.0 Profile", 2011 <a href="http://swordapp.github.io/SWORDv2-Profile/SWORDProfile.html">http://swordapp.github.io/SWORDv2-Profile/SWORDProfile.html</a></p></p>

    </div>



</body>
</html>